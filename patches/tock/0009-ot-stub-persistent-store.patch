diff --git a/chips/lowrisc/src/flash_ctrl.rs b/chips/lowrisc/src/flash_ctrl.rs
index 656b8bca7..15b27658f 100644
--- a/chips/lowrisc/src/flash_ctrl.rs
+++ b/chips/lowrisc/src/flash_ctrl.rs
@@ -2,12 +2,18 @@
 
 use core::cell::Cell;
 use core::ops::{Index, IndexMut};
+use kernel::grant::AllowRoCount;
+use kernel::grant::AllowRwCount;
+use kernel::grant::Grant;
+use kernel::grant::UpcallCount;
+use kernel::syscall::CommandReturn;
 use kernel::utilities::cells::OptionalCell;
 use kernel::utilities::cells::TakeCell;
 use kernel::utilities::registers::interfaces::{ReadWriteable, Readable, Writeable};
 use kernel::utilities::registers::{
     register_bitfields, register_structs, ReadOnly, ReadWrite, WriteOnly,
 };
+use kernel::ProcessId;
 
 use kernel::hil;
 use kernel::utilities::StaticRef;
@@ -259,6 +265,8 @@ register_bitfields![u32,
 pub const PAGE_SIZE: usize = 2048;
 pub const FLASH_WORD_SIZE: usize = 8;
 pub const FLASH_PAGES_PER_BANK: usize = 256;
+const MAX_WORD_WRITES: u32 = 2;
+const MAX_PAGE_ERASES: u32 = 10_000;
 pub const FLASH_NUM_BANKS: usize = 2;
 pub const FLASH_MAX_PAGES: usize = FLASH_NUM_BANKS * FLASH_PAGES_PER_BANK;
 pub const FLASH_NUM_BUSWORDS_PER_BANK: usize = PAGE_SIZE / 4;
@@ -759,3 +767,87 @@ impl hil::flash::Flash for FlashCtrl<'_> {
         Ok(())
     }
 }
+
+type PersistentStorageDriverGrant = Grant<App, UpcallCount<1>, AllowRoCount<1>, AllowRwCount<0>>;
+
+/// Provides access to the writeable flash regions of the application. STUB for OpenTitan for now.
+///
+/// The purpose of this driver is to provide low-level access to the embedded flash of nRF52 boards
+/// to allow applications to implement flash-aware (like wear-leveling) data-structures. The driver
+/// only permits applications to operate on their writeable flash regions. The API is blocking since
+/// the CPU is halted during write and erase operations.
+///
+/// Supported boards:
+/// - nRF52840 (tested)
+/// - nRF52833
+/// - nRF52811
+/// - nRF52810
+///
+/// The maximum number of writes for the nRF52832 board is not per word but per block (512 bytes)
+/// and as such doesn't exactly fit this API. However, it could be safely supported by returning
+/// either 1 for the maximum number of word writes (i.e. the flash can only be written once before
+/// being erased) or 8 for the word size (i.e. the write granularity is doubled). In both cases,
+/// only 128 writes per block are permitted while the flash supports 181.
+///
+/// # Syscalls
+///
+/// - SUBSCRIBE(0, done): The callback for COMMAND(2) and COMMAND(3).
+/// - COMMAND(0): Check the driver.
+/// - COMMAND(1, 0): Get the word size (always 4).
+/// - COMMAND(1, 1): Get the page size (always 4096).
+/// - COMMAND(1, 2): Get the maximum number of word writes between page erasures (always 2).
+/// - COMMAND(1, 3): Get the maximum number page erasures in the lifetime of the flash (always
+///     10000).
+/// - COMMAND(2, ptr, len): Write the allow slice to the flash region starting at `ptr`.
+///   - `ptr` must be word-aligned.
+///   - The allow slice length must be word aligned.
+///   - The region starting at `ptr` of the same length as the allow slice must be in a writeable
+///     flash region.
+/// - COMMAND(3, ptr, len): Erase a page.
+///   - `ptr` must be page-aligned.
+///   - The page starting at `ptr` must be in a writeable flash region.
+/// - ALLOW(0): The allow slice for COMMAND(2).
+pub struct PersistentStorageDriver {
+    apps: PersistentStorageDriverGrant,
+}
+
+impl PersistentStorageDriver {
+    pub fn new(apps: PersistentStorageDriverGrant) -> Self {
+        Self { apps }
+    }
+}
+
+pub const DRIVER_NUM: usize = 0x50_003;
+
+#[derive(Default)]
+pub struct App {}
+
+impl kernel::syscall::SyscallDriver for PersistentStorageDriver {
+    fn allocate_grant(&self, process_id: ProcessId) -> Result<(), kernel::process::Error> {
+        self.apps.enter(process_id, |_, _| {})
+    }
+
+    fn command(
+        &self,
+        command_num: usize,
+        r2: usize,
+        r3: usize,
+        _process_id: ProcessId,
+    ) -> CommandReturn {
+        match (command_num, r2, r3) {
+            (0, _, _) => CommandReturn::success(),
+
+            (1, 0, _) => CommandReturn::success_u32(FLASH_WORD_SIZE.try_into().unwrap()),
+            (1, 1, _) => CommandReturn::success_u32(PAGE_SIZE.try_into().unwrap()),
+            (1, 2, _) => CommandReturn::success_u32(MAX_WORD_WRITES),
+            (1, 3, _) => CommandReturn::success_u32(MAX_PAGE_ERASES),
+            (1, _, _) => CommandReturn::failure(ErrorCode::INVAL),
+
+            // do nothing for now writing/erasing slices as it is for now just a stub
+            (2, _ptr, _len) => CommandReturn::success(),
+            (3, _ptr, _len) => CommandReturn::success(),
+
+            _ => CommandReturn::failure(ErrorCode::NOSUPPORT),
+        }
+    }
+}
