From e1de13ca235177b14e76d77536fc8fa3c98662aa Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Fri, 4 Nov 2022 19:52:21 +0100
Subject: [PATCH 01/27] WIP: 02-usb.patch

---
 .gitignore                        |   3 +
 02-usb.patch                      | 103 ++++++++
 capsules/src/driver.rs            |   2 +
 capsules/src/usb/mod.rs           |   2 +
 capsules/src/usb/usb_ctap.rs      | 412 ++++++++++++++++++++++++++++++
 capsules/src/usb/usbc_ctap_hid.rs | 369 ++++++++++++++++++++++++++
 6 files changed, 891 insertions(+)
 create mode 100644 02-usb.patch
 create mode 100644 capsules/src/usb/usb_ctap.rs
 create mode 100644 capsules/src/usb/usbc_ctap_hid.rs

diff --git a/.gitignore b/.gitignore
index f9c5c95af..a0352b7e9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -80,3 +80,6 @@ boards/esp32-c3-devkitM-1/binary.hex
 
 # Redboard Artemis Nano test binary
 boards/apollo3/redboard_artemis_nano/redboard-artemis-nano-tests.bin
+
+# ctags
+**/tags
diff --git a/02-usb.patch b/02-usb.patch
new file mode 100644
index 000000000..e35046a94
--- /dev/null
+++ b/02-usb.patch
@@ -0,0 +1,103 @@
+diff --git a/boards/components/src/lib.rs b/boards/components/src/lib.rs
+index 64fe46b7b..a3bbe724b 100644
+--- a/boards/components/src/lib.rs
++++ b/boards/components/src/lib.rs
+@@ -52,3 +52,4 @@ pub mod tickv;
+ pub mod touch;
+ pub mod udp_driver;
+ pub mod udp_mux;
++pub mod usb_ctap;
+diff --git a/boards/components/src/usb_ctap.rs b/boards/components/src/usb_ctap.rs
+new file mode 100644
+index 000000000..69e95c3c7
+--- /dev/null
++++ b/boards/components/src/usb_ctap.rs
+@@ -0,0 +1,88 @@
++//! Component for CTAP over USB.
++
++use capsules::usb::usb_ctap::CtapUsbSyscallDriver;
++use capsules::usb::usbc_ctap_hid::ClientCtapHID;
++use core::mem::MaybeUninit;
++use kernel::capabilities;
++use kernel::component::Component;
++use kernel::create_capability;
++use kernel::hil;
++use kernel::static_init_half;
++
++// Setup static space for the objects.
++#[macro_export]
++macro_rules! usb_ctap_component_buf {
++    ($C:ty) => {{
++        use capsules::usb::usb_ctap::CtapUsbSyscallDriver;
++        use capsules::usb::usbc_ctap_hid::ClientCtapHID;
++        use core::mem::MaybeUninit;
++        static mut BUF1: MaybeUninit<ClientCtapHID<'static, 'static, $C>> = MaybeUninit::uninit();
++        static mut BUF2: MaybeUninit<CtapUsbSyscallDriver<'static, 'static, $C>> =
++            MaybeUninit::uninit();
++        (&mut BUF1, &mut BUF2)
++    };};
++}
++
++pub struct UsbCtapComponent<C: 'static + hil::usb::UsbController<'static>> {
++    board_kernel: &'static kernel::Kernel,
++    controller: &'static C,
++    max_ctrl_packet_size: u8,
++    vendor_id: u16,
++    product_id: u16,
++    strings: &'static [&'static str],
++}
++
++impl<C: 'static + hil::usb::UsbController<'static>> UsbCtapComponent<C> {
++    pub fn new(
++        board_kernel: &'static kernel::Kernel,
++        controller: &'static C,
++        max_ctrl_packet_size: u8,
++        vendor_id: u16,
++        product_id: u16,
++        strings: &'static [&'static str],
++    ) -> Self {
++        Self {
++            board_kernel,
++            controller,
++            max_ctrl_packet_size,
++            vendor_id,
++            product_id,
++            strings,
++        }
++    }
++}
++
++impl<C: 'static + hil::usb::UsbController<'static>> Component for UsbCtapComponent<C> {
++    type StaticInput = (
++        &'static mut MaybeUninit<ClientCtapHID<'static, 'static, C>>,
++        &'static mut MaybeUninit<CtapUsbSyscallDriver<'static, 'static, C>>,
++    );
++    type Output = &'static CtapUsbSyscallDriver<'static, 'static, C>;
++
++    unsafe fn finalize(self, static_buffer: Self::StaticInput) -> Self::Output {
++        let grant_cap = create_capability!(capabilities::MemoryAllocationCapability);
++
++        let usb_ctap = static_init_half!(
++            static_buffer.0,
++            ClientCtapHID<'static, 'static, C>,
++            ClientCtapHID::new(
++                self.controller,
++                self.max_ctrl_packet_size,
++                self.vendor_id,
++                self.product_id,
++                self.strings,
++            )
++        );
++        self.controller.set_client(usb_ctap);
++
++        // Configure the USB userspace driver
++        let usb_driver = static_init_half!(
++            static_buffer.1,
++            CtapUsbSyscallDriver<'static, 'static, C>,
++            CtapUsbSyscallDriver::new(usb_ctap, self.board_kernel.create_grant(&grant_cap))
++        );
++        usb_ctap.set_client(usb_driver);
++
++        usb_driver
++    }
++}
diff --git a/capsules/src/driver.rs b/capsules/src/driver.rs
index f189dfd09..c48c7e094 100644
--- a/capsules/src/driver.rs
+++ b/capsules/src/driver.rs
@@ -29,6 +29,8 @@ pub enum NUM {
     UsbUser               = 0x20005,
     I2cMasterSlave        = 0x20006,
 
+    UsbCtap               = 0x20009,
+
     // Radio
     BleAdvertising        = 0x30000,
     Ieee802154            = 0x30001,
diff --git a/capsules/src/usb/mod.rs b/capsules/src/usb/mod.rs
index 6d5daa444..17cab4c23 100644
--- a/capsules/src/usb/mod.rs
+++ b/capsules/src/usb/mod.rs
@@ -1,6 +1,8 @@
 pub mod cdc;
 pub mod ctap;
 pub mod descriptors;
+pub mod usb_ctap;
 pub mod usb_user;
 pub mod usbc_client;
 pub mod usbc_client_ctrl;
+pub mod usbc_ctap_hid;
diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
new file mode 100644
index 000000000..3f50b2ca5
--- /dev/null
+++ b/capsules/src/usb/usb_ctap.rs
@@ -0,0 +1,412 @@
+use core::mem;
+
+use super::usbc_ctap_hid::ClientCtapHID;
+use kernel::errorcode::ErrorCode;
+use kernel::grant::{AllowRoCount, AllowRwCount, Grant, UpcallCount};
+use kernel::hil;
+use kernel::hil::usb::Client;
+use kernel::processbuffer::WriteableProcessBuffer;
+use kernel::processbuffer::{ReadWriteProcessBuffer, ReadableProcessBuffer};
+use kernel::syscall::{CommandReturn, SyscallDriver};
+use kernel::upcall::UpcallId;
+use kernel::ProcessId;
+
+/// Syscall number
+use crate::driver;
+pub const DRIVER_NUM: usize = driver::NUM::UsbCtap as usize;
+
+pub const CTAP_CMD_CHECK: usize = 0;
+pub const CTAP_CMD_CONNECT: usize = 1;
+pub const CTAP_CMD_TRANSMIT: usize = 2;
+pub const CTAP_CMD_RECEIVE: usize = 3;
+pub const CTAP_CMD_TRANSMIT_OR_RECEIVE: usize = 4;
+pub const CTAP_CMD_CANCEL: usize = 5;
+
+pub const CTAP_ALLOW_TRANSMIT: usize = 1;
+pub const CTAP_ALLOW_RECEIVE: usize = 2;
+pub const CTAP_ALLOW_TRANSMIT_OR_RECEIVE: usize = 3;
+
+pub const CTAP_SUBSCRIBE_TRANSMIT: usize = 1;
+pub const CTAP_SUBSCRIBE_RECEIVE: usize = 2;
+pub const CTAP_SUBSCRIBE_TRANSMIT_OR_RECEIVE: usize = 3;
+
+pub const CTAP_CALLBACK_TRANSMITED: usize = 1;
+pub const CTAP_CALLBACK_RECEIVED: usize = 2;
+
+type CtabUsbDriverGrant = Grant<App, UpcallCount<1>, AllowRoCount<1>, AllowRwCount<1>>;
+
+#[derive(Clone, Copy, PartialEq, Eq)]
+enum Side {
+    Transmit,
+    Receive,
+    TransmitOrReceive,
+}
+
+impl Side {
+    fn can_transmit(&self) -> bool {
+        match self {
+            Side::Transmit | Side::TransmitOrReceive => true,
+            Side::Receive => false,
+        }
+    }
+
+    fn can_receive(&self) -> bool {
+        match self {
+            Side::Receive | Side::TransmitOrReceive => true,
+            Side::Transmit => false,
+        }
+    }
+}
+
+#[derive(Default)]
+pub struct App {
+    // Only one app can be connected to this driver, to avoid needing to route packets among apps.
+    // This field tracks this status.
+    connected: bool,
+    // Currently enabled transaction side. Subscribing to a callback or allowing a buffer
+    // automatically sets the corresponding side. Clearing both the callback and the buffer resets
+    // the side to None.
+    side: Option<Side>,
+    upcall: Option<UpcallId>,
+    buffer: Option<ReadWriteProcessBuffer>,
+    // Whether the app is waiting for the kernel signaling a packet transfer.
+    waiting: bool,
+}
+
+impl App {
+    fn check_side(&mut self) {
+        if self.upcall.is_none() && self.buffer.is_none() && !self.waiting {
+            self.side = None;
+        }
+    }
+
+    fn set_side(&mut self, side: Side) -> bool {
+        match self.side {
+            None => {
+                self.side = Some(side);
+                true
+            }
+            Some(app_side) => side == app_side,
+        }
+    }
+
+    fn is_ready_for_command(&self, side: Side) -> bool {
+        self.buffer.is_some() && self.upcall.is_some() && self.side == Some(side)
+    }
+}
+
+pub trait CtapUsbClient {
+    // Whether this client is ready to receive a packet. This must be checked before calling
+    // packet_received().
+    fn can_receive_packet(&self) -> bool;
+
+    // Signal to the client that a packet has been received.
+    fn packet_received(&self, packet: &[u8; 64]);
+
+    // Signal to the client that a packet has been transmitted.
+    fn packet_transmitted(&self);
+}
+
+pub struct CtapUsbSyscallDriver<'a, 'b, C: 'a> {
+    usb_client: &'a ClientCtapHID<'a, 'b, C>,
+    apps: CtabUsbDriverGrant,
+}
+
+impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbSyscallDriver<'a, 'b, C> {
+    pub fn new(usb_client: &'a ClientCtapHID<'a, 'b, C>, apps: CtabUsbDriverGrant) -> Self {
+        CtapUsbSyscallDriver { usb_client, apps }
+    }
+}
+
+impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDriver<'a, 'b, C> {
+    fn can_receive_packet(&self) -> bool {
+        let mut result = false;
+        for app in self.apps.iter() {
+            app.enter(|app, _| {
+                if app.connected {
+                    result = app.waiting
+                        && app.side.map_or(false, |side| side.can_receive())
+                        && app.buffer.is_some();
+                }
+            });
+        }
+        result
+    }
+
+    fn packet_received(&self, packet: &[u8; 64]) {
+        for app in self.apps.iter() {
+            app.enter(|app, kernel_data| {
+                if app.connected && app.waiting && app.side.map_or(false, |side| side.can_receive())
+                {
+                    if let Some(buf) = &mut app.buffer {
+                        // Copy the packet to the app's allowed buffer.
+                        buf.mut_enter(|mut_buf| mut_buf.copy_from_slice(packet))
+                            .unwrap();
+                        app.waiting = false;
+                        // Signal to the app that a packet is ready.
+                        kernel_data
+                            .schedule_upcall(0, (CTAP_CALLBACK_RECEIVED, 0, 0))
+                            .unwrap();
+                    }
+                }
+            });
+        }
+    }
+
+    fn packet_transmitted(&self) {
+        for app in self.apps.iter() {
+            app.enter(|app, kernel_data| {
+                if app.connected
+                    && app.waiting
+                    && app.side.map_or(false, |side| side.can_transmit())
+                {
+                    app.waiting = false;
+                    // Signal to the app that the packet was sent.
+                    kernel_data
+                        .schedule_upcall(0, (CTAP_CALLBACK_TRANSMITED, 0, 0))
+                        .unwrap();
+                }
+            });
+        }
+    }
+}
+
+impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDriver<'a, 'b, C> {
+    fn allow_userspace_readable(
+        &self,
+        app_process_id: ProcessId,
+        which: usize,
+        mut slice: kernel::processbuffer::UserspaceReadableProcessBuffer,
+    ) -> Result<
+        kernel::processbuffer::UserspaceReadableProcessBuffer,
+        (
+            kernel::processbuffer::UserspaceReadableProcessBuffer,
+            ErrorCode,
+        ),
+    > {
+        let side = match which {
+            CTAP_ALLOW_TRANSMIT => Side::Transmit,
+            CTAP_ALLOW_RECEIVE => Side::Receive,
+            CTAP_ALLOW_TRANSMIT_OR_RECEIVE => Side::TransmitOrReceive,
+            _ => return Err((slice, ErrorCode::NOSUPPORT)),
+        };
+
+        let res = self
+            .apps
+            .enter(app_process_id, |app, _| {
+                if !app.connected {
+                    Err(ErrorCode::RESERVE)
+                } else {
+                    if slice.len() != 64 {
+                        return Err(ErrorCode::INVAL);
+                    }
+                    if !app.set_side(side) {
+                        return Err(ErrorCode::ALREADY);
+                    }
+                    app.check_side();
+
+                    if let Some(buf) = &mut app.buffer {
+                        mem::swap(buf, &mut slice);
+                        Ok(())
+                    } else {
+                        Err(ErrorCode::FAIL)
+                    }
+                }
+            })
+            .map_err(ErrorCode::from);
+
+        if let Err(e) = res {
+            Err((slice, e))
+        } else {
+            Ok(slice)
+        }
+    }
+
+    fn allocate_grant(&self, process_id: ProcessId) -> Result<(), kernel::process::Error> {
+        self.apps.enter(process_id, |_, _| {})
+    }
+
+    /*
+    fn subscribe(
+        &self,
+        subscribe_num: usize,
+        callback: Option<Callback>,
+        processId: ProcessId,
+    ) -> Result<(), ErrorCode> {
+        let side = match subscribe_num {
+            CTAP_SUBSCRIBE_TRANSMIT => Side::Transmit,
+            CTAP_SUBSCRIBE_RECEIVE => Side::Receive,
+            CTAP_SUBSCRIBE_TRANSMIT_OR_RECEIVE => Side::TransmitOrReceive,
+            _ => return Err(ErrorCode::NOSUPPORT),
+        };
+        self.apps
+            .enter(processId, |app, _| {
+                if !app.connected {
+                    Err(ErrorCode::RESERVE)
+                } else {
+                    if !app.set_side(side) {
+                        return Err(ErrorCode::ALREADY);
+                    }
+                    app.upcall = callback;
+                    app.check_side();
+                    Ok(())
+                }
+            })
+            .unwrap_or_else(|err| err.into())
+    } */
+
+    fn command(
+        &self,
+        cmd_num: usize,
+        _arg1: usize,
+        _arg2: usize,
+        process_id: ProcessId,
+    ) -> CommandReturn {
+        match cmd_num {
+            CTAP_CMD_CHECK => CommandReturn::success(),
+            CTAP_CMD_CONNECT => {
+                // First, check if any app is already connected to this driver.
+                let mut busy = false;
+                for app in self.apps.iter() {
+                    app.enter(|app, _| {
+                        busy |= app.connected;
+                    });
+                }
+
+                self.apps
+                    .enter(process_id, |app, _| {
+                        if app.connected {
+                            CommandReturn::failure(ErrorCode::ALREADY)
+                        } else if busy {
+                            CommandReturn::failure(ErrorCode::BUSY)
+                        } else {
+                            self.usb_client.enable();
+                            self.usb_client.attach();
+                            app.connected = true;
+                            CommandReturn::success()
+                        }
+                    })
+                    .unwrap_or_else(|err| err.into())
+            }
+            CTAP_CMD_TRANSMIT => self
+                .apps
+                .enter(process_id, |app, _| {
+                    if !app.connected {
+                        CommandReturn::failure(ErrorCode::RESERVE)
+                    } else {
+                        if app.is_ready_for_command(Side::Transmit) {
+                            if app.waiting {
+                                CommandReturn::failure(ErrorCode::ALREADY)
+                            } else if self.usb_client.transmit_packet(
+                                app.buffer
+                                    .as_ref()
+                                    .unwrap()
+                                    .enter(|slice| {
+                                        let mut packet: [u8; 64] = [0; 64];
+                                        slice.copy_to_slice(&mut packet);
+                                        packet
+                                    })
+                                    .unwrap()
+                                    .as_ref(),
+                            ) {
+                                app.waiting = true;
+                                CommandReturn::success()
+                            } else {
+                                CommandReturn::failure(ErrorCode::BUSY)
+                            }
+                        } else {
+                            CommandReturn::failure(ErrorCode::INVAL)
+                        }
+                    }
+                })
+                .unwrap_or_else(|err| err.into()),
+            CTAP_CMD_RECEIVE => self
+                .apps
+                .enter(process_id, |app, _| {
+                    if !app.connected {
+                        CommandReturn::failure(ErrorCode::RESERVE)
+                    } else {
+                        if app.is_ready_for_command(Side::Receive) {
+                            if app.waiting {
+                                CommandReturn::failure(ErrorCode::ALREADY)
+                            } else {
+                                app.waiting = true;
+                                self.usb_client.receive_packet();
+                                CommandReturn::success()
+                            }
+                        } else {
+                            CommandReturn::failure(ErrorCode::INVAL)
+                        }
+                    }
+                })
+                .unwrap_or_else(|err| err.into()),
+            CTAP_CMD_TRANSMIT_OR_RECEIVE => self
+                .apps
+                .enter(process_id, |app, _| {
+                    if !app.connected {
+                        CommandReturn::failure(ErrorCode::RESERVE)
+                    } else {
+                        if app.is_ready_for_command(Side::TransmitOrReceive) {
+                            if app.waiting {
+                                CommandReturn::failure(ErrorCode::ALREADY)
+                            } else {
+                                // Indicates to the driver that we can receive any pending packet.
+                                app.waiting = true;
+                                self.usb_client.receive_packet();
+
+                                if !app.waiting {
+                                    // The call to receive_packet() collected a pending packet.
+                                    CommandReturn::success()
+                                } else {
+                                    // Indicates to the driver that we have a packet to send.
+                                    if self.usb_client.transmit_packet(
+                                        app.buffer
+                                            .as_ref()
+                                            .unwrap()
+                                            .enter(|slice| {
+                                                let mut packet: [u8; 64] = [0; 64];
+                                                slice.copy_to_slice(&mut packet);
+                                                packet
+                                            })
+                                            .unwrap()
+                                            .as_ref(),
+                                    ) {
+                                        CommandReturn::success()
+                                    } else {
+                                        CommandReturn::failure(ErrorCode::BUSY)
+                                    }
+                                }
+                            }
+                        } else {
+                            CommandReturn::failure(ErrorCode::INVAL)
+                        }
+                    }
+                })
+                .unwrap_or_else(|err| err.into()),
+            CTAP_CMD_CANCEL => self
+                .apps
+                .enter(process_id, |app, _| {
+                    if !app.connected {
+                        CommandReturn::failure(ErrorCode::RESERVE)
+                    } else {
+                        if app.waiting {
+                            // FIXME: if cancellation failed, the app should still wait. But that
+                            // doesn't work yet.
+                            app.waiting = false;
+                            if self.usb_client.cancel_transaction() {
+                                CommandReturn::success()
+                            } else {
+                                // Cannot cancel now because the transaction is already in process.
+                                // The app should wait for the callback instead.
+                                CommandReturn::failure(ErrorCode::BUSY)
+                            }
+                        } else {
+                            CommandReturn::failure(ErrorCode::ALREADY)
+                        }
+                    }
+                })
+                .unwrap_or_else(|err| err.into()),
+            _ => CommandReturn::failure(ErrorCode::NOSUPPORT),
+        }
+    }
+}
diff --git a/capsules/src/usb/usbc_ctap_hid.rs b/capsules/src/usb/usbc_ctap_hid.rs
new file mode 100644
index 000000000..eeaa99e0b
--- /dev/null
+++ b/capsules/src/usb/usbc_ctap_hid.rs
@@ -0,0 +1,369 @@
+//! A USB HID client of the USB hardware interface
+
+use super::descriptors;
+use super::descriptors::Buffer64;
+use super::descriptors::DescriptorType;
+use super::descriptors::EndpointAddress;
+use super::descriptors::EndpointDescriptor;
+use super::descriptors::HIDCountryCode;
+use super::descriptors::HIDDescriptor;
+use super::descriptors::HIDSubordinateDescriptor;
+use super::descriptors::InterfaceDescriptor;
+use super::descriptors::ReportDescriptor;
+use super::descriptors::TransferDirection;
+use super::usb_ctap::CtapUsbClient;
+use super::usbc_client_ctrl::ClientCtrl;
+use core::cell::Cell;
+use kernel::debug;
+use kernel::hil;
+use kernel::hil::usb::TransferType;
+use kernel::utilities::cells::OptionalCell;
+
+static LANGUAGES: &'static [u16; 1] = &[
+    0x0409, // English (United States)
+];
+
+const ENDPOINT_NUM: usize = 1;
+
+static CTAP_REPORT_DESCRIPTOR: &'static [u8] = &[
+    0x06, 0xD0, 0xF1, // HID_UsagePage ( FIDO_USAGE_PAGE ),
+    0x09, 0x01, // HID_Usage ( FIDO_USAGE_CTAPHID ),
+    0xA1, 0x01, // HID_Collection ( HID_Application ),
+    0x09, 0x20, // HID_Usage ( FIDO_USAGE_DATA_IN ),
+    0x15, 0x00, // HID_LogicalMin ( 0 ),
+    0x26, 0xFF, 0x00, // HID_LogicalMaxS ( 0xff ),
+    0x75, 0x08, // HID_ReportSize ( 8 ),
+    0x95, 0x40, // HID_ReportCount ( HID_INPUT_REPORT_BYTES ),
+    0x81, 0x02, // HID_Input ( HID_Data | HID_Absolute | HID_Variable ),
+    0x09, 0x21, // HID_Usage ( FIDO_USAGE_DATA_OUT ),
+    0x15, 0x00, // HID_LogicalMin ( 0 ),
+    0x26, 0xFF, 0x00, // HID_LogicalMaxS ( 0xff ),
+    0x75, 0x08, // HID_ReportSize ( 8 ),
+    0x95, 0x40, // HID_ReportCount ( HID_OUTPUT_REPORT_BYTES ),
+    0x91, 0x02, // HID_Output ( HID_Data | HID_Absolute | HID_Variable ),
+    0xC0, // HID_EndCollection
+];
+
+static CTAP_REPORT: ReportDescriptor<'static> = ReportDescriptor {
+    desc: CTAP_REPORT_DESCRIPTOR,
+};
+
+static HID_SUB_DESCRIPTORS: &'static [HIDSubordinateDescriptor] = &[HIDSubordinateDescriptor {
+    typ: DescriptorType::Report,
+    len: CTAP_REPORT_DESCRIPTOR.len() as u16,
+}];
+
+static HID: HIDDescriptor<'static> = HIDDescriptor {
+    hid_class: 0x0110,
+    country_code: HIDCountryCode::NotSupported,
+    sub_descriptors: HID_SUB_DESCRIPTORS,
+};
+
+pub struct ClientCtapHID<'a, 'b, C: 'a> {
+    client_ctrl: ClientCtrl<'a, 'static, C>,
+
+    // 64-byte buffers for the endpoint
+    in_buffer: Buffer64,
+    out_buffer: Buffer64,
+
+    // Interaction with the client
+    client: OptionalCell<&'b dyn CtapUsbClient>,
+    tx_packet: OptionalCell<[u8; 64]>,
+    pending_in: Cell<bool>,
+    pending_out: Cell<bool>,
+    delayed_out: Cell<bool>,
+}
+
+impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
+    pub fn new(
+        controller: &'a C,
+        max_ctrl_packet_size: u8,
+        vendor_id: u16,
+        product_id: u16,
+        strings: &'static [&'static str],
+    ) -> Self {
+        let interfaces: &mut [InterfaceDescriptor] = &mut [
+            // Interface declared in the FIDO2 specification, section 8.1.8.1
+            InterfaceDescriptor {
+                interface_class: 0x03, // HID
+                interface_subclass: 0x00,
+                interface_protocol: 0x00,
+                ..InterfaceDescriptor::default()
+            },
+        ];
+
+        let endpoints: &[&[EndpointDescriptor]] = &[&[
+            EndpointDescriptor {
+                endpoint_address: EndpointAddress::new_const(
+                    ENDPOINT_NUM,
+                    TransferDirection::HostToDevice,
+                ),
+                transfer_type: TransferType::Interrupt,
+                max_packet_size: 64,
+                interval: 5,
+            },
+            EndpointDescriptor {
+                endpoint_address: EndpointAddress::new_const(
+                    ENDPOINT_NUM,
+                    TransferDirection::DeviceToHost,
+                ),
+                transfer_type: TransferType::Interrupt,
+                max_packet_size: 64,
+                interval: 5,
+            },
+        ]];
+
+        let (device_descriptor_buffer, other_descriptor_buffer) =
+            descriptors::create_descriptor_buffers(
+                descriptors::DeviceDescriptor {
+                    vendor_id,
+                    product_id,
+                    manufacturer_string: 1,
+                    product_string: 2,
+                    serial_number_string: 3,
+                    max_packet_size_ep0: max_ctrl_packet_size,
+                    ..descriptors::DeviceDescriptor::default()
+                },
+                descriptors::ConfigurationDescriptor {
+                    configuration_value: 1,
+                    ..descriptors::ConfigurationDescriptor::default()
+                },
+                interfaces,
+                endpoints,
+                Some(&HID),
+                None, // No CDC descriptor array
+            );
+
+        ClientCtapHID {
+            client_ctrl: ClientCtrl::new(
+                controller,
+                device_descriptor_buffer,
+                other_descriptor_buffer,
+                Some(&HID),
+                Some(&CTAP_REPORT),
+                LANGUAGES,
+                strings,
+            ),
+            in_buffer: Buffer64::default(),
+            out_buffer: Buffer64::default(),
+            client: OptionalCell::empty(),
+            tx_packet: OptionalCell::empty(),
+            pending_in: Cell::new(false),
+            pending_out: Cell::new(false),
+            delayed_out: Cell::new(false),
+        }
+    }
+
+    pub fn set_client(&'a self, client: &'b dyn CtapUsbClient) {
+        self.client.set(client);
+    }
+
+    pub fn transmit_packet(&'a self, packet: &[u8]) -> bool {
+        if self.pending_in.get() {
+            // The previous packet has not yet been transmitted, reject the new one.
+            false
+        } else {
+            self.pending_in.set(true);
+            let mut buf: [u8; 64] = [0; 64];
+            buf.copy_from_slice(packet);
+            self.tx_packet.set(buf);
+            // Alert the controller that we now have data to send on the Interrupt IN endpoint.
+            self.controller().endpoint_resume_in(1);
+            true
+        }
+    }
+
+    pub fn receive_packet(&'a self) -> bool {
+        if self.pending_out.get() {
+            // The previous packet has not yet been received, reject the new one.
+            false
+        } else {
+            self.pending_out.set(true);
+            // In case we reported Delay before, send the pending packet back to the client.
+            // Otherwise, there's nothing to do, the controller will send us a packet_out when a
+            // packet arrives.
+            if self.delayed_out.take() {
+                if self.send_packet_to_client() {
+                    // If that succeeds, alert the controller that we can now
+                    // receive data on the Interrupt OUT endpoint.
+                    self.controller().endpoint_resume_out(1);
+                }
+            }
+            true
+        }
+    }
+
+    // Send an OUT packet available in the controller back to the client.
+    // This returns false if the client is not ready to receive a packet, and true if the client
+    // successfully accepted the packet.
+    fn send_packet_to_client(&'a self) -> bool {
+        // Copy the packet into a buffer to send to the client.
+        let mut buf: [u8; 64] = [0; 64];
+        for (i, x) in self.out_buffer.buf.iter().enumerate() {
+            buf[i] = x.get();
+        }
+
+        assert!(!self.delayed_out.get());
+
+        // Notify the client
+        if self
+            .client
+            .map_or(false, |client| client.can_receive_packet())
+        {
+            assert!(self.pending_out.take());
+
+            // Clear any pending packet on the transmitting side.
+            // It's up to the client to handle the received packet and decide if this packet
+            // should be re-transmitted or not.
+            self.cancel_in_transaction();
+
+            self.client.map(|client| client.packet_received(&buf));
+            true
+        } else {
+            // Cannot receive now, indicate a delay to the controller.
+            self.delayed_out.set(true);
+            false
+        }
+    }
+
+    pub fn cancel_transaction(&'a self) -> bool {
+        self.cancel_in_transaction() | self.cancel_out_transaction()
+    }
+
+    fn cancel_in_transaction(&'a self) -> bool {
+        self.tx_packet.take();
+        self.pending_in.take()
+    }
+
+    fn cancel_out_transaction(&'a self) -> bool {
+        self.pending_out.take()
+    }
+
+    #[inline]
+    fn controller(&'a self) -> &'a C {
+        self.client_ctrl.controller()
+    }
+}
+
+impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtapHID<'a, 'b, C> {
+    fn enable(&'a self) {
+        // Set up the default control endpoint
+        self.client_ctrl.enable();
+
+        // Set up the interrupt in-out endpoint
+        self.controller()
+            .endpoint_set_in_buffer(1, &self.in_buffer.buf);
+        self.controller()
+            .endpoint_set_out_buffer(1, &self.out_buffer.buf);
+        self.controller()
+            .endpoint_in_out_enable(TransferType::Interrupt, 1);
+    }
+
+    fn attach(&'a self) {
+        self.client_ctrl.attach();
+    }
+
+    fn bus_reset(&'a self) {
+        // Should the client initiate reconfiguration here?
+        // For now, the hardware layer does it.
+
+        debug!("Bus reset");
+    }
+
+    /// Handle a Control Setup transaction
+    fn ctrl_setup(&'a self, endpoint: usize) -> hil::usb::CtrlSetupResult {
+        self.client_ctrl.ctrl_setup(endpoint)
+    }
+
+    /// Handle a Control In transaction
+    fn ctrl_in(&'a self, endpoint: usize) -> hil::usb::CtrlInResult {
+        self.client_ctrl.ctrl_in(endpoint)
+    }
+
+    /// Handle a Control Out transaction
+    fn ctrl_out(&'a self, endpoint: usize, packet_bytes: u32) -> hil::usb::CtrlOutResult {
+        self.client_ctrl.ctrl_out(endpoint, packet_bytes)
+    }
+
+    fn ctrl_status(&'a self, endpoint: usize) {
+        self.client_ctrl.ctrl_status(endpoint)
+    }
+
+    /// Handle the completion of a Control transfer
+    fn ctrl_status_complete(&'a self, endpoint: usize) {
+        self.client_ctrl.ctrl_status_complete(endpoint)
+    }
+
+    /// Handle a Bulk/Interrupt IN transaction
+    fn packet_in(&'a self, transfer_type: TransferType, endpoint: usize) -> hil::usb::InResult {
+        match transfer_type {
+            TransferType::Bulk => hil::usb::InResult::Error,
+            TransferType::Interrupt => {
+                if endpoint != 1 {
+                    return hil::usb::InResult::Error;
+                }
+
+                if let Some(packet) = self.tx_packet.take() {
+                    let buf = &self.in_buffer.buf;
+                    for i in 0..64 {
+                        buf[i].set(packet[i]);
+                    }
+
+                    hil::usb::InResult::Packet(64)
+                } else {
+                    // Nothing to send
+                    hil::usb::InResult::Delay
+                }
+            }
+            TransferType::Control | TransferType::Isochronous => unreachable!(),
+        }
+    }
+
+    /// Handle a Bulk/Interrupt OUT transaction
+    fn packet_out(
+        &'a self,
+        transfer_type: TransferType,
+        endpoint: usize,
+        packet_bytes: u32,
+    ) -> hil::usb::OutResult {
+        match transfer_type {
+            TransferType::Bulk => hil::usb::OutResult::Error,
+            TransferType::Interrupt => {
+                if endpoint != 1 {
+                    return hil::usb::OutResult::Error;
+                }
+
+                if packet_bytes != 64 {
+                    // Cannot process this packet
+                    hil::usb::OutResult::Error
+                } else {
+                    if self.send_packet_to_client() {
+                        hil::usb::OutResult::Ok
+                    } else {
+                        hil::usb::OutResult::Delay
+                    }
+                }
+            }
+            TransferType::Control | TransferType::Isochronous => unreachable!(),
+        }
+    }
+
+    fn packet_transmitted(&'a self, endpoint: usize) {
+        if endpoint != 1 {
+            panic!("Unexpected transmission on ep {}", endpoint);
+        }
+
+        if self.tx_packet.is_some() {
+            panic!("Unexpected tx_packet while a packet was being transmitted.");
+        }
+        self.pending_in.set(false);
+
+        // Clear any pending packet on the receiving side.
+        // It's up to the client to handle the transmitted packet and decide if they want to
+        // receive another packet.
+        self.cancel_out_transaction();
+
+        // Notify the client
+        self.client.map(|client| client.packet_transmitted());
+    }
+}
-- 
2.34.1


From 1b51c03eae3f470e359b7dc25c55b4684fd31143 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Sat, 5 Nov 2022 18:17:23 +0100
Subject: [PATCH 02/27] Draft of 02-usb.patch

---
 02-usb.patch                      | 103 --------------
 boards/components/src/lib.rs      |   1 +
 boards/components/src/usb_ctap.rs |  85 ++++++++++++
 capsules/src/usb/usb_ctap.rs      | 218 +++++++++++-------------------
 4 files changed, 166 insertions(+), 241 deletions(-)
 delete mode 100644 02-usb.patch
 create mode 100644 boards/components/src/usb_ctap.rs

diff --git a/02-usb.patch b/02-usb.patch
deleted file mode 100644
index e35046a94..000000000
--- a/02-usb.patch
+++ /dev/null
@@ -1,103 +0,0 @@
-diff --git a/boards/components/src/lib.rs b/boards/components/src/lib.rs
-index 64fe46b7b..a3bbe724b 100644
---- a/boards/components/src/lib.rs
-+++ b/boards/components/src/lib.rs
-@@ -52,3 +52,4 @@ pub mod tickv;
- pub mod touch;
- pub mod udp_driver;
- pub mod udp_mux;
-+pub mod usb_ctap;
-diff --git a/boards/components/src/usb_ctap.rs b/boards/components/src/usb_ctap.rs
-new file mode 100644
-index 000000000..69e95c3c7
---- /dev/null
-+++ b/boards/components/src/usb_ctap.rs
-@@ -0,0 +1,88 @@
-+//! Component for CTAP over USB.
-+
-+use capsules::usb::usb_ctap::CtapUsbSyscallDriver;
-+use capsules::usb::usbc_ctap_hid::ClientCtapHID;
-+use core::mem::MaybeUninit;
-+use kernel::capabilities;
-+use kernel::component::Component;
-+use kernel::create_capability;
-+use kernel::hil;
-+use kernel::static_init_half;
-+
-+// Setup static space for the objects.
-+#[macro_export]
-+macro_rules! usb_ctap_component_buf {
-+    ($C:ty) => {{
-+        use capsules::usb::usb_ctap::CtapUsbSyscallDriver;
-+        use capsules::usb::usbc_ctap_hid::ClientCtapHID;
-+        use core::mem::MaybeUninit;
-+        static mut BUF1: MaybeUninit<ClientCtapHID<'static, 'static, $C>> = MaybeUninit::uninit();
-+        static mut BUF2: MaybeUninit<CtapUsbSyscallDriver<'static, 'static, $C>> =
-+            MaybeUninit::uninit();
-+        (&mut BUF1, &mut BUF2)
-+    };};
-+}
-+
-+pub struct UsbCtapComponent<C: 'static + hil::usb::UsbController<'static>> {
-+    board_kernel: &'static kernel::Kernel,
-+    controller: &'static C,
-+    max_ctrl_packet_size: u8,
-+    vendor_id: u16,
-+    product_id: u16,
-+    strings: &'static [&'static str],
-+}
-+
-+impl<C: 'static + hil::usb::UsbController<'static>> UsbCtapComponent<C> {
-+    pub fn new(
-+        board_kernel: &'static kernel::Kernel,
-+        controller: &'static C,
-+        max_ctrl_packet_size: u8,
-+        vendor_id: u16,
-+        product_id: u16,
-+        strings: &'static [&'static str],
-+    ) -> Self {
-+        Self {
-+            board_kernel,
-+            controller,
-+            max_ctrl_packet_size,
-+            vendor_id,
-+            product_id,
-+            strings,
-+        }
-+    }
-+}
-+
-+impl<C: 'static + hil::usb::UsbController<'static>> Component for UsbCtapComponent<C> {
-+    type StaticInput = (
-+        &'static mut MaybeUninit<ClientCtapHID<'static, 'static, C>>,
-+        &'static mut MaybeUninit<CtapUsbSyscallDriver<'static, 'static, C>>,
-+    );
-+    type Output = &'static CtapUsbSyscallDriver<'static, 'static, C>;
-+
-+    unsafe fn finalize(self, static_buffer: Self::StaticInput) -> Self::Output {
-+        let grant_cap = create_capability!(capabilities::MemoryAllocationCapability);
-+
-+        let usb_ctap = static_init_half!(
-+            static_buffer.0,
-+            ClientCtapHID<'static, 'static, C>,
-+            ClientCtapHID::new(
-+                self.controller,
-+                self.max_ctrl_packet_size,
-+                self.vendor_id,
-+                self.product_id,
-+                self.strings,
-+            )
-+        );
-+        self.controller.set_client(usb_ctap);
-+
-+        // Configure the USB userspace driver
-+        let usb_driver = static_init_half!(
-+            static_buffer.1,
-+            CtapUsbSyscallDriver<'static, 'static, C>,
-+            CtapUsbSyscallDriver::new(usb_ctap, self.board_kernel.create_grant(&grant_cap))
-+        );
-+        usb_ctap.set_client(usb_driver);
-+
-+        usb_driver
-+    }
-+}
diff --git a/boards/components/src/lib.rs b/boards/components/src/lib.rs
index f6784c466..1d0360689 100644
--- a/boards/components/src/lib.rs
+++ b/boards/components/src/lib.rs
@@ -74,3 +74,4 @@ pub mod touch;
 pub mod udp_driver;
 pub mod udp_mux;
 pub mod usb;
+pub mod usb_ctap;
diff --git a/boards/components/src/usb_ctap.rs b/boards/components/src/usb_ctap.rs
new file mode 100644
index 000000000..bfee8c832
--- /dev/null
+++ b/boards/components/src/usb_ctap.rs
@@ -0,0 +1,85 @@
+//! Component for CTAP over USB.
+
+use capsules::usb::usb_ctap::CtapUsbSyscallDriver;
+use capsules::usb::usbc_ctap_hid::ClientCtapHID;
+use core::mem::MaybeUninit;
+use kernel::capabilities;
+use kernel::component::Component;
+use kernel::create_capability;
+use kernel::hil;
+
+// Setup static space for the objects.
+#[macro_export]
+macro_rules! usb_ctap_component_buf {
+    ($C:ty) => {{
+        use capsules::usb::usb_ctap::CtapUsbSyscallDriver;
+        use capsules::usb::usbc_ctap_hid::ClientCtapHID;
+        use core::mem::MaybeUninit;
+        static mut BUF1: MaybeUninit<ClientCtapHID<'static, 'static, $C>> = MaybeUninit::uninit();
+        static mut BUF2: MaybeUninit<CtapUsbSyscallDriver<'static, 'static, $C>> =
+            MaybeUninit::uninit();
+        (&mut BUF1, &mut BUF2)
+    };};
+}
+
+pub struct UsbCtapComponent<C: 'static + hil::usb::UsbController<'static>> {
+    board_kernel: &'static kernel::Kernel,
+    driver_num: usize,
+    controller: &'static C,
+    max_ctrl_packet_size: u8,
+    vendor_id: u16,
+    product_id: u16,
+    strings: &'static [&'static str],
+}
+
+impl<C: 'static + hil::usb::UsbController<'static>> UsbCtapComponent<C> {
+    pub fn new(
+        board_kernel: &'static kernel::Kernel,
+        driver_num: usize,
+        controller: &'static C,
+        max_ctrl_packet_size: u8,
+        vendor_id: u16,
+        product_id: u16,
+        strings: &'static [&'static str],
+    ) -> Self {
+        Self {
+            board_kernel,
+            driver_num,
+            controller,
+            max_ctrl_packet_size,
+            vendor_id,
+            product_id,
+            strings,
+        }
+    }
+}
+
+impl<C: 'static + hil::usb::UsbController<'static>> Component for UsbCtapComponent<C> {
+    type StaticInput = (
+        &'static mut MaybeUninit<ClientCtapHID<'static, 'static, C>>,
+        &'static mut MaybeUninit<CtapUsbSyscallDriver<'static, 'static, C>>,
+    );
+    type Output = &'static CtapUsbSyscallDriver<'static, 'static, C>;
+
+    fn finalize(self, s: Self::StaticInput) -> Self::Output {
+        let grant_cap = create_capability!(capabilities::MemoryAllocationCapability);
+
+        let usb_ctap = s.0.write(ClientCtapHID::new(
+            self.controller,
+            self.max_ctrl_packet_size,
+            self.vendor_id,
+            self.product_id,
+            self.strings,
+        ));
+        self.controller.set_client(usb_ctap);
+
+        // Configure the USB userspace driver
+        let usb_driver = s.1.write(CtapUsbSyscallDriver::new(
+            usb_ctap,
+            self.board_kernel.create_grant(self.driver_num, &grant_cap),
+        ));
+        usb_ctap.set_client(usb_driver);
+
+        usb_driver
+    }
+}
diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index 3f50b2ca5..308ab5d51 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -1,14 +1,10 @@
-use core::mem;
-
 use super::usbc_ctap_hid::ClientCtapHID;
 use kernel::errorcode::ErrorCode;
 use kernel::grant::{AllowRoCount, AllowRwCount, Grant, UpcallCount};
 use kernel::hil;
 use kernel::hil::usb::Client;
-use kernel::processbuffer::WriteableProcessBuffer;
-use kernel::processbuffer::{ReadWriteProcessBuffer, ReadableProcessBuffer};
+use kernel::processbuffer::{ReadableProcessBuffer, WriteableProcessBuffer};
 use kernel::syscall::{CommandReturn, SyscallDriver};
-use kernel::upcall::UpcallId;
 use kernel::ProcessId;
 
 /// Syscall number
@@ -22,18 +18,22 @@ pub const CTAP_CMD_RECEIVE: usize = 3;
 pub const CTAP_CMD_TRANSMIT_OR_RECEIVE: usize = 4;
 pub const CTAP_CMD_CANCEL: usize = 5;
 
+// todo: figure out what do with them
 pub const CTAP_ALLOW_TRANSMIT: usize = 1;
 pub const CTAP_ALLOW_RECEIVE: usize = 2;
 pub const CTAP_ALLOW_TRANSMIT_OR_RECEIVE: usize = 3;
 
+// todo: figure out what do with them
+// ids for the subscribe syscalls
 pub const CTAP_SUBSCRIBE_TRANSMIT: usize = 1;
 pub const CTAP_SUBSCRIBE_RECEIVE: usize = 2;
 pub const CTAP_SUBSCRIBE_TRANSMIT_OR_RECEIVE: usize = 3;
 
-pub const CTAP_CALLBACK_TRANSMITED: usize = 1;
-pub const CTAP_CALLBACK_RECEIVED: usize = 2;
+// the different kinds of subscribe upcalls triggered inside the application when the corresponding event happens
+pub const CTAP_CALLBACK_TRANSMITED_SUBSCRIBE_NUM: usize = 0;
+pub const CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM: usize = 1;
 
-type CtabUsbDriverGrant = Grant<App, UpcallCount<1>, AllowRoCount<1>, AllowRwCount<1>>;
+type CtabUsbDriverGrant = Grant<App, UpcallCount<2>, AllowRoCount<1>, AllowRwCount<1>>;
 
 #[derive(Clone, Copy, PartialEq, Eq)]
 enum Side {
@@ -67,15 +67,13 @@ pub struct App {
     // automatically sets the corresponding side. Clearing both the callback and the buffer resets
     // the side to None.
     side: Option<Side>,
-    upcall: Option<UpcallId>,
-    buffer: Option<ReadWriteProcessBuffer>,
     // Whether the app is waiting for the kernel signaling a packet transfer.
     waiting: bool,
 }
 
 impl App {
     fn check_side(&mut self) {
-        if self.upcall.is_none() && self.buffer.is_none() && !self.waiting {
+        if !self.waiting {
             self.side = None;
         }
     }
@@ -91,7 +89,7 @@ impl App {
     }
 
     fn is_ready_for_command(&self, side: Side) -> bool {
-        self.buffer.is_some() && self.upcall.is_some() && self.side == Some(side)
+        self.side == Some(side)
     }
 }
 
@@ -124,9 +122,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDri
         for app in self.apps.iter() {
             app.enter(|app, _| {
                 if app.connected {
-                    result = app.waiting
-                        && app.side.map_or(false, |side| side.can_receive())
-                        && app.buffer.is_some();
+                    result = app.waiting && app.side.map_or(false, |side| side.can_receive());
                 }
             });
         }
@@ -138,18 +134,27 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDri
             app.enter(|app, kernel_data| {
                 if app.connected && app.waiting && app.side.map_or(false, |side| side.can_receive())
                 {
-                    if let Some(buf) = &mut app.buffer {
-                        // Copy the packet to the app's allowed buffer.
-                        buf.mut_enter(|mut_buf| mut_buf.copy_from_slice(packet))
-                            .unwrap();
-                        app.waiting = false;
-                        // Signal to the app that a packet is ready.
-                        kernel_data
-                            .schedule_upcall(0, (CTAP_CALLBACK_RECEIVED, 0, 0))
-                            .unwrap();
-                    }
+                    kernel_data
+                        .get_readwrite_processbuffer(1)
+                        .and_then(|process_buffer| {
+                            process_buffer
+                                .mut_enter(|buf| buf.copy_from_slice(packet))
+                                .unwrap();
+                            app.waiting = false;
+                            // Signal to the app that a packet is ready.
+                            kernel_data
+                                .schedule_upcall(CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM, (0, 0, 0))
+                                .unwrap();
+                            // reset the client state
+                            app.check_side();
+
+                            Ok(())
+                        })
+                } else {
+                    Err(kernel::process::Error::KernelError)
                 }
-            });
+            })
+            .unwrap();
         }
     }
 
@@ -163,8 +168,11 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDri
                     app.waiting = false;
                     // Signal to the app that the packet was sent.
                     kernel_data
-                        .schedule_upcall(0, (CTAP_CALLBACK_TRANSMITED, 0, 0))
+                        .schedule_upcall(CTAP_CALLBACK_TRANSMITED_SUBSCRIBE_NUM, (0, 0, 0))
                         .unwrap();
+
+                    // reset the client state
+                    app.check_side();
                 }
             });
         }
@@ -172,89 +180,10 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDri
 }
 
 impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDriver<'a, 'b, C> {
-    fn allow_userspace_readable(
-        &self,
-        app_process_id: ProcessId,
-        which: usize,
-        mut slice: kernel::processbuffer::UserspaceReadableProcessBuffer,
-    ) -> Result<
-        kernel::processbuffer::UserspaceReadableProcessBuffer,
-        (
-            kernel::processbuffer::UserspaceReadableProcessBuffer,
-            ErrorCode,
-        ),
-    > {
-        let side = match which {
-            CTAP_ALLOW_TRANSMIT => Side::Transmit,
-            CTAP_ALLOW_RECEIVE => Side::Receive,
-            CTAP_ALLOW_TRANSMIT_OR_RECEIVE => Side::TransmitOrReceive,
-            _ => return Err((slice, ErrorCode::NOSUPPORT)),
-        };
-
-        let res = self
-            .apps
-            .enter(app_process_id, |app, _| {
-                if !app.connected {
-                    Err(ErrorCode::RESERVE)
-                } else {
-                    if slice.len() != 64 {
-                        return Err(ErrorCode::INVAL);
-                    }
-                    if !app.set_side(side) {
-                        return Err(ErrorCode::ALREADY);
-                    }
-                    app.check_side();
-
-                    if let Some(buf) = &mut app.buffer {
-                        mem::swap(buf, &mut slice);
-                        Ok(())
-                    } else {
-                        Err(ErrorCode::FAIL)
-                    }
-                }
-            })
-            .map_err(ErrorCode::from);
-
-        if let Err(e) = res {
-            Err((slice, e))
-        } else {
-            Ok(slice)
-        }
-    }
-
     fn allocate_grant(&self, process_id: ProcessId) -> Result<(), kernel::process::Error> {
         self.apps.enter(process_id, |_, _| {})
     }
 
-    /*
-    fn subscribe(
-        &self,
-        subscribe_num: usize,
-        callback: Option<Callback>,
-        processId: ProcessId,
-    ) -> Result<(), ErrorCode> {
-        let side = match subscribe_num {
-            CTAP_SUBSCRIBE_TRANSMIT => Side::Transmit,
-            CTAP_SUBSCRIBE_RECEIVE => Side::Receive,
-            CTAP_SUBSCRIBE_TRANSMIT_OR_RECEIVE => Side::TransmitOrReceive,
-            _ => return Err(ErrorCode::NOSUPPORT),
-        };
-        self.apps
-            .enter(processId, |app, _| {
-                if !app.connected {
-                    Err(ErrorCode::RESERVE)
-                } else {
-                    if !app.set_side(side) {
-                        return Err(ErrorCode::ALREADY);
-                    }
-                    app.upcall = callback;
-                    app.check_side();
-                    Ok(())
-                }
-            })
-            .unwrap_or_else(|err| err.into())
-    } */
-
     fn command(
         &self,
         cmd_num: usize,
@@ -290,29 +219,34 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
             }
             CTAP_CMD_TRANSMIT => self
                 .apps
-                .enter(process_id, |app, _| {
+                .enter(process_id, |app, kernel| {
                     if !app.connected {
                         CommandReturn::failure(ErrorCode::RESERVE)
                     } else {
+                        // set the client state to transmit packets
+                        if !app.set_side(Side::Transmit) {
+                            return CommandReturn::failure(ErrorCode::INVAL);
+                        }
+
                         if app.is_ready_for_command(Side::Transmit) {
                             if app.waiting {
                                 CommandReturn::failure(ErrorCode::ALREADY)
-                            } else if self.usb_client.transmit_packet(
-                                app.buffer
-                                    .as_ref()
-                                    .unwrap()
-                                    .enter(|slice| {
-                                        let mut packet: [u8; 64] = [0; 64];
-                                        slice.copy_to_slice(&mut packet);
-                                        packet
-                                    })
-                                    .unwrap()
-                                    .as_ref(),
-                            ) {
-                                app.waiting = true;
-                                CommandReturn::success()
                             } else {
-                                CommandReturn::failure(ErrorCode::BUSY)
+                                kernel
+                                    .get_readonly_processbuffer(1)
+                                    .and_then(|buffer| {
+                                        buffer.enter(|buf| {
+                                            let mut packet: [u8; 64] = [0; 64];
+                                            buf.copy_to_slice(&mut packet);
+                                            if self.usb_client.transmit_packet(&packet) {
+                                                app.waiting = true;
+                                                CommandReturn::success()
+                                            } else {
+                                                CommandReturn::failure(ErrorCode::BUSY)
+                                            }
+                                        })
+                                    })
+                                    .unwrap_or(CommandReturn::failure(ErrorCode::FAIL))
                             }
                         } else {
                             CommandReturn::failure(ErrorCode::INVAL)
@@ -326,6 +260,10 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                     if !app.connected {
                         CommandReturn::failure(ErrorCode::RESERVE)
                     } else {
+                        // set the client state to recive packets
+                        if !app.set_side(Side::Receive) {
+                            return CommandReturn::failure(ErrorCode::INVAL);
+                        }
                         if app.is_ready_for_command(Side::Receive) {
                             if app.waiting {
                                 CommandReturn::failure(ErrorCode::ALREADY)
@@ -342,10 +280,15 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                 .unwrap_or_else(|err| err.into()),
             CTAP_CMD_TRANSMIT_OR_RECEIVE => self
                 .apps
-                .enter(process_id, |app, _| {
+                .enter(process_id, |app, kernel| {
                     if !app.connected {
                         CommandReturn::failure(ErrorCode::RESERVE)
                     } else {
+                        // set the client state
+                        if !app.set_side(Side::TransmitOrReceive) {
+                            return CommandReturn::failure(ErrorCode::INVAL);
+                        }
+
                         if app.is_ready_for_command(Side::TransmitOrReceive) {
                             if app.waiting {
                                 CommandReturn::failure(ErrorCode::ALREADY)
@@ -358,23 +301,22 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                                     // The call to receive_packet() collected a pending packet.
                                     CommandReturn::success()
                                 } else {
-                                    // Indicates to the driver that we have a packet to send.
-                                    if self.usb_client.transmit_packet(
-                                        app.buffer
-                                            .as_ref()
-                                            .unwrap()
-                                            .enter(|slice| {
+                                    kernel
+                                        .get_readonly_processbuffer(1)
+                                        .and_then(|process_buffer| {
+                                            process_buffer.enter(|buf| {
                                                 let mut packet: [u8; 64] = [0; 64];
-                                                slice.copy_to_slice(&mut packet);
-                                                packet
+                                                buf.copy_to_slice(&mut packet);
+
+                                                // Indicates to the driver that we have a packet to send.
+                                                if self.usb_client.transmit_packet(&packet) {
+                                                    CommandReturn::success()
+                                                } else {
+                                                    CommandReturn::failure(ErrorCode::BUSY)
+                                                }
                                             })
-                                            .unwrap()
-                                            .as_ref(),
-                                    ) {
-                                        CommandReturn::success()
-                                    } else {
-                                        CommandReturn::failure(ErrorCode::BUSY)
-                                    }
+                                        })
+                                        .unwrap_or(CommandReturn::failure(ErrorCode::FAIL))
                                 }
                             }
                         } else {
-- 
2.34.1


From 146c870d4a4488e4c1ed32ff2ed5478177812cbd Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Sun, 6 Nov 2022 16:36:36 +0100
Subject: [PATCH 03/27] Add 08-remove-unused-ctap-module.patch

---
 boards/components/src/ctap.rs | 119 ----------
 boards/components/src/lib.rs  |   1 -
 capsules/src/usb/ctap.rs      | 406 ----------------------------------
 capsules/src/usb/mod.rs       |   1 -
 4 files changed, 527 deletions(-)
 delete mode 100644 boards/components/src/ctap.rs
 delete mode 100644 capsules/src/usb/ctap.rs

diff --git a/boards/components/src/ctap.rs b/boards/components/src/ctap.rs
deleted file mode 100644
index ae77d674f..000000000
--- a/boards/components/src/ctap.rs
+++ /dev/null
@@ -1,119 +0,0 @@
-//! Component for CTAP HID over USB support.
-//!
-//! This provides a component for using the CTAP driver. This allows for
-//! Client to Authenticator Protocol Authentication.
-//!
-//! Usage
-//! -----
-//! ```rust
-//! static STRINGS: &'static [&str; 3] = &[
-//!     "XYZ Corp.",     // Manufacturer
-//!     "FIDO Key",      // Product
-//!     "Serial No. 5",  // Serial number
-//! ];
-//!
-//!     let (ctap, ctap_driver) = components::ctap::CtapComponent::new(
-//!         &earlgrey::usbdev::USB,
-//!         0x1337, // My important company
-//!         0x0DEC, // My device name
-//!         strings,
-//!         board_kernel,
-//!         ctap_send_buffer,
-//!         ctap_recv_buffer,
-//!     )
-//!     .finalize(components::ctap_component_static!(lowrisc::usbdev::Usb));
-//!
-//!     ctap.enable();
-//!     ctap.attach();
-//! ```
-
-use core::mem::MaybeUninit;
-use kernel::capabilities;
-use kernel::component::Component;
-use kernel::create_capability;
-use kernel::hil;
-
-// Setup static space for the objects.
-#[macro_export]
-macro_rules! ctap_component_static {
-    ($U:ty $(,)?) => {{
-        let hid = kernel::static_buf!(capsules::usb::ctap::CtapHid<'static, $U>);
-        let driver = kernel::static_buf!(
-            capsules::ctap::CtapDriver<'static, capsules::usb::ctap::CtapHid<'static, $U>>
-        );
-        let send_buffer = kernel::static_buf!([u8; 64]);
-        let recv_buffer = kernel::static_buf!([u8; 64]);
-
-        (hid, driver, send_buffer, recv_buffer)
-    };};
-}
-
-pub struct CtapComponent<U: 'static + hil::usb::UsbController<'static>> {
-    board_kernel: &'static kernel::Kernel,
-    driver_num: usize,
-    usb: &'static U,
-    vendor_id: u16,
-    product_id: u16,
-    strings: &'static [&'static str; 3],
-}
-
-impl<U: 'static + hil::usb::UsbController<'static>> CtapComponent<U> {
-    pub fn new(
-        board_kernel: &'static kernel::Kernel,
-        driver_num: usize,
-        usb: &'static U,
-        vendor_id: u16,
-        product_id: u16,
-        strings: &'static [&'static str; 3],
-    ) -> CtapComponent<U> {
-        CtapComponent {
-            board_kernel,
-            driver_num,
-            usb,
-            vendor_id,
-            product_id,
-            strings,
-        }
-    }
-}
-
-impl<U: 'static + hil::usb::UsbController<'static>> Component for CtapComponent<U> {
-    type StaticInput = (
-        &'static mut MaybeUninit<capsules::usb::ctap::CtapHid<'static, U>>,
-        &'static mut MaybeUninit<
-            capsules::ctap::CtapDriver<'static, capsules::usb::ctap::CtapHid<'static, U>>,
-        >,
-        &'static mut MaybeUninit<[u8; 64]>,
-        &'static mut MaybeUninit<[u8; 64]>,
-    );
-    type Output = (
-        &'static capsules::usb::ctap::CtapHid<'static, U>,
-        &'static capsules::ctap::CtapDriver<'static, capsules::usb::ctap::CtapHid<'static, U>>,
-    );
-
-    fn finalize(self, s: Self::StaticInput) -> Self::Output {
-        let ctap = s.0.write(capsules::usb::ctap::CtapHid::new(
-            self.usb,
-            self.vendor_id,
-            self.product_id,
-            self.strings,
-        ));
-        self.usb.set_client(ctap);
-
-        let grant_cap = create_capability!(capabilities::MemoryAllocationCapability);
-
-        let send_buffer = s.2.write([0; 64]);
-        let recv_buffer = s.3.write([0; 64]);
-
-        let ctap_driver = s.1.write(capsules::ctap::CtapDriver::new(
-            Some(ctap),
-            send_buffer,
-            recv_buffer,
-            self.board_kernel.create_grant(self.driver_num, &grant_cap),
-        ));
-
-        ctap.set_client(ctap_driver);
-
-        (ctap, ctap_driver)
-    }
-}
diff --git a/boards/components/src/lib.rs b/boards/components/src/lib.rs
index 1d0360689..bb5778216 100644
--- a/boards/components/src/lib.rs
+++ b/boards/components/src/lib.rs
@@ -16,7 +16,6 @@ pub mod ccs811;
 pub mod cdc;
 pub mod console;
 pub mod crc;
-pub mod ctap;
 pub mod dac;
 pub mod debug_queue;
 pub mod debug_writer;
diff --git a/capsules/src/usb/ctap.rs b/capsules/src/usb/ctap.rs
deleted file mode 100644
index d085b7286..000000000
--- a/capsules/src/usb/ctap.rs
+++ /dev/null
@@ -1,406 +0,0 @@
-//! Client to Authenticator Protocol CTAPv2 over USB HID
-//!
-//! Based on the spec avaliable at: <https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-client-to-authenticator-protocol-v2.0-id-20180227.html>
-
-use core::cell::Cell;
-use core::cmp;
-
-use super::descriptors;
-use super::descriptors::Buffer64;
-use super::descriptors::DescriptorType;
-use super::descriptors::EndpointAddress;
-use super::descriptors::EndpointDescriptor;
-use super::descriptors::HIDCountryCode;
-use super::descriptors::HIDDescriptor;
-use super::descriptors::HIDSubordinateDescriptor;
-use super::descriptors::InterfaceDescriptor;
-use super::descriptors::ReportDescriptor;
-use super::descriptors::TransferDirection;
-use super::usbc_client_ctrl::ClientCtrl;
-
-use kernel::hil;
-use kernel::hil::usb::TransferType;
-use kernel::utilities::cells::OptionalCell;
-use kernel::utilities::cells::TakeCell;
-use kernel::ErrorCode;
-
-/// Use 1 Interrupt transfer IN/OUT endpoint
-const ENDPOINT_NUM: usize = 1;
-
-const OUT_BUFFER: usize = 0;
-const IN_BUFFER: usize = 1;
-
-static LANGUAGES: &'static [u16; 1] = &[
-    0x0409, // English (United States)
-];
-/// Max packet size specified by spec
-pub const MAX_CTRL_PACKET_SIZE: u8 = 64;
-
-const N_ENDPOINTS: usize = 2;
-
-/// The HID report descriptor for CTAP
-/// This is a combination of:
-///     - the CTAP spec, example 8
-///     - USB HID spec examples
-/// Plus it matches: https://chromium.googlesource.com/chromiumos/platform2/+/master/u2fd/u2fhid.cc
-static REPORT_DESCRIPTOR: &'static [u8] = &[
-    0x06, 0xD0, 0xF1, // HID_UsagePage ( FIDO_USAGE_PAGE ),
-    0x09, 0x01, // HID_Usage ( FIDO_USAGE_CTAPHID ),
-    0xA1, 0x01, // HID_Collection ( HID_Application ),
-    0x09, 0x20, // HID_Usage ( FIDO_USAGE_DATA_IN ),
-    0x15, 0x00, // HID_LogicalMin ( 0 ),
-    0x26, 0xFF, 0x00, // HID_LogicalMaxS ( 0xff ),
-    0x75, 0x08, // HID_ReportSize ( 8 ),
-    0x95, 0x40, // HID_ReportCount ( HID_INPUT_REPORT_BYTES ),
-    0x81, 0x02, // HID_Input ( HID_Data | HID_Absolute | HID_Variable ),
-    0x09, 0x21, // HID_Usage ( FIDO_USAGE_DATA_OUT ),
-    0x15, 0x00, // HID_LogicalMin ( 0 ),
-    0x26, 0xFF, 0x00, // HID_LogicalMaxS ( 0xff ),
-    0x75, 0x08, // HID_ReportSize ( 8 ),
-    0x95, 0x40, // HID_ReportCount ( HID_OUTPUT_REPORT_BYTES ),
-    0x91, 0x02, // HID_Output ( HID_Data | HID_Absolute | HID_Variable ),
-    0xC0, // HID_EndCollection
-];
-
-static REPORT: ReportDescriptor<'static> = ReportDescriptor {
-    desc: REPORT_DESCRIPTOR,
-};
-
-static SUB_HID_DESCRIPTOR: &'static [HIDSubordinateDescriptor] = &[HIDSubordinateDescriptor {
-    typ: DescriptorType::Report,
-    len: REPORT_DESCRIPTOR.len() as u16,
-}];
-
-static HID_DESCRIPTOR: HIDDescriptor<'static> = HIDDescriptor {
-    hid_class: 0x0110,
-    country_code: HIDCountryCode::NotSupported,
-    sub_descriptors: SUB_HID_DESCRIPTOR,
-};
-
-/// Implementation of the CTAP HID (Human Interface Device)
-pub struct CtapHid<'a, U: 'a> {
-    /// Helper USB client library for handling many USB operations.
-    client_ctrl: ClientCtrl<'a, 'static, U>,
-
-    /// 64 byte buffers for each endpoint.
-    buffers: [Buffer64; N_ENDPOINTS],
-
-    client: OptionalCell<&'a dyn hil::usb_hid::Client<'a, [u8; 64]>>,
-
-    /// A buffer to hold the data we want to send
-    send_buffer: TakeCell<'static, [u8; 64]>,
-
-    /// A holder for the buffer to receive bytes into. We use this as a flag as
-    /// well, if we have a buffer then we are actively doing a receive.
-    recv_buffer: TakeCell<'static, [u8; 64]>,
-    /// How many bytes the client wants us to receive.
-    recv_len: Cell<usize>,
-    /// How many bytes we have received so far.
-    recv_offset: Cell<usize>,
-
-    saved_endpoint: OptionalCell<usize>,
-}
-
-impl<'a, U: hil::usb::UsbController<'a>> CtapHid<'a, U> {
-    pub fn new(
-        controller: &'a U,
-        vendor_id: u16,
-        product_id: u16,
-        strings: &'static [&'static str; 3],
-    ) -> Self {
-        let interfaces: &mut [InterfaceDescriptor] = &mut [InterfaceDescriptor {
-            interface_number: 0,
-            interface_class: 0x03,    // HID
-            interface_subclass: 0x00, // No subcall
-            interface_protocol: 0x00, // No protocol
-            ..InterfaceDescriptor::default()
-        }];
-
-        let endpoints: &[&[EndpointDescriptor]] = &[&[
-            EndpointDescriptor {
-                endpoint_address: EndpointAddress::new_const(
-                    ENDPOINT_NUM,
-                    TransferDirection::DeviceToHost,
-                ),
-                transfer_type: TransferType::Interrupt,
-                max_packet_size: 64,
-                interval: 5,
-            },
-            EndpointDescriptor {
-                endpoint_address: EndpointAddress::new_const(
-                    ENDPOINT_NUM,
-                    TransferDirection::HostToDevice,
-                ),
-                transfer_type: TransferType::Interrupt,
-                max_packet_size: 64,
-                interval: 5,
-            },
-        ]];
-
-        let (device_descriptor_buffer, other_descriptor_buffer) =
-            descriptors::create_descriptor_buffers(
-                descriptors::DeviceDescriptor {
-                    vendor_id: vendor_id,
-                    product_id: product_id,
-                    manufacturer_string: 1,
-                    product_string: 2,
-                    serial_number_string: 3,
-                    class: 0x03, // Class: HID
-                    max_packet_size_ep0: MAX_CTRL_PACKET_SIZE,
-                    ..descriptors::DeviceDescriptor::default()
-                },
-                descriptors::ConfigurationDescriptor {
-                    ..descriptors::ConfigurationDescriptor::default()
-                },
-                interfaces,
-                endpoints,
-                Some(&HID_DESCRIPTOR),
-                None,
-            );
-
-        CtapHid {
-            client_ctrl: ClientCtrl::new(
-                controller,
-                device_descriptor_buffer,
-                other_descriptor_buffer,
-                Some(&HID_DESCRIPTOR),
-                Some(&REPORT),
-                LANGUAGES,
-                strings,
-            ),
-            buffers: [Buffer64::default(), Buffer64::default()],
-            client: OptionalCell::empty(),
-            send_buffer: TakeCell::empty(),
-            recv_buffer: TakeCell::empty(),
-            recv_len: Cell::new(0),
-            recv_offset: Cell::new(0),
-            saved_endpoint: OptionalCell::empty(),
-        }
-    }
-
-    #[inline]
-    fn controller(&self) -> &'a U {
-        self.client_ctrl.controller()
-    }
-
-    pub fn set_client(&'a self, client: &'a dyn hil::usb_hid::Client<'a, [u8; 64]>) {
-        self.client.set(client);
-    }
-
-    fn can_receive(&'a self) -> bool {
-        self.client
-            .map(move |client| client.can_receive())
-            .unwrap_or(false)
-    }
-}
-
-impl<'a, U: hil::usb::UsbController<'a>> hil::usb_hid::UsbHid<'a, [u8; 64]> for CtapHid<'a, U> {
-    fn send_buffer(
-        &'a self,
-        send: &'static mut [u8; 64],
-    ) -> Result<usize, (ErrorCode, &'static mut [u8; 64])> {
-        let len = send.len();
-
-        self.send_buffer.replace(send);
-        self.controller().endpoint_resume_in(ENDPOINT_NUM);
-
-        Ok(len)
-    }
-
-    fn send_cancel(&'a self) -> Result<&'static mut [u8; 64], ErrorCode> {
-        match self.send_buffer.take() {
-            Some(buf) => Ok(buf),
-            None => Err(ErrorCode::BUSY),
-        }
-    }
-
-    fn receive_buffer(
-        &'a self,
-        recv: &'static mut [u8; 64],
-    ) -> Result<(), (ErrorCode, &'static mut [u8; 64])> {
-        self.recv_buffer.replace(recv);
-
-        if self.saved_endpoint.is_some() {
-            // We have saved data from before, let's pass it.
-            if self.can_receive() {
-                self.recv_buffer.take().map(|buf| {
-                    self.client.map(move |client| {
-                        client.packet_received(Ok(()), buf, self.saved_endpoint.take().unwrap());
-                    });
-                });
-                // Reset the offset
-                self.recv_offset.set(0);
-            }
-        } else {
-            // If we have nothing to process, accept more data
-            self.controller().endpoint_resume_out(ENDPOINT_NUM);
-        }
-
-        Ok(())
-    }
-
-    fn receive_cancel(&'a self) -> Result<&'static mut [u8; 64], ErrorCode> {
-        self.saved_endpoint.take();
-        match self.recv_buffer.take() {
-            Some(buf) => Ok(buf),
-            None => Err(ErrorCode::BUSY),
-        }
-    }
-}
-
-impl<'a, U: hil::usb::UsbController<'a>> hil::usb::Client<'a> for CtapHid<'a, U> {
-    fn enable(&'a self) {
-        // Set up the default control endpoint
-        self.client_ctrl.enable();
-
-        // Setup buffers for IN and OUT data transfer.
-        self.controller()
-            .endpoint_set_out_buffer(ENDPOINT_NUM, &self.buffers[OUT_BUFFER].buf);
-        self.controller()
-            .endpoint_set_in_buffer(ENDPOINT_NUM, &self.buffers[IN_BUFFER].buf);
-        self.controller()
-            .endpoint_in_out_enable(TransferType::Interrupt, ENDPOINT_NUM);
-    }
-
-    fn attach(&'a self) {
-        self.client_ctrl.attach();
-    }
-
-    fn bus_reset(&'a self) {}
-
-    /// Handle a Control Setup transaction.
-    fn ctrl_setup(&'a self, endpoint: usize) -> hil::usb::CtrlSetupResult {
-        self.client_ctrl.ctrl_setup(endpoint)
-    }
-
-    /// Handle a Control In transaction
-    fn ctrl_in(&'a self, endpoint: usize) -> hil::usb::CtrlInResult {
-        self.client_ctrl.ctrl_in(endpoint)
-    }
-
-    /// Handle a Control Out transaction
-    fn ctrl_out(&'a self, endpoint: usize, packet_bytes: u32) -> hil::usb::CtrlOutResult {
-        self.client_ctrl.ctrl_out(endpoint, packet_bytes)
-    }
-
-    fn ctrl_status(&'a self, endpoint: usize) {
-        self.client_ctrl.ctrl_status(endpoint)
-    }
-
-    /// Handle the completion of a Control transfer
-    fn ctrl_status_complete(&'a self, endpoint: usize) {
-        if self.send_buffer.is_some() {
-            self.controller().endpoint_resume_in(ENDPOINT_NUM);
-        }
-
-        self.client_ctrl.ctrl_status_complete(endpoint)
-    }
-
-    /// Handle a Bulk/Interrupt IN transaction.
-    ///
-    /// This is called when we can send data to the host. It should get called
-    /// when we tell the controller we want to resume the IN endpoint (meaning
-    /// we know we have data to send) and afterwards until we return
-    /// `hil::usb::InResult::Delay` from this function. That means we can use
-    /// this as a callback to mean that the transmission finished by waiting
-    /// until this function is called when we don't have anything left to send.
-    fn packet_in(&'a self, transfer_type: TransferType, _endpoint: usize) -> hil::usb::InResult {
-        match transfer_type {
-            TransferType::Interrupt => {
-                self.send_buffer
-                    .take()
-                    .map_or(hil::usb::InResult::Delay, |buf| {
-                        // Get packet that we have shared with the underlying
-                        // USB stack to copy the tx into.
-                        let packet = &self.buffers[IN_BUFFER].buf;
-
-                        // Copy from the TX buffer to the outgoing USB packet.
-                        for i in 0..64 {
-                            packet[i].set(buf[i]);
-                        }
-
-                        // Put the TX buffer back so we can keep sending from it.
-                        self.send_buffer.replace(buf);
-
-                        // Return that we have data to send.
-                        hil::usb::InResult::Packet(64)
-                    })
-            }
-            TransferType::Bulk | TransferType::Control | TransferType::Isochronous => {
-                panic!("Transfer protocol not supported by CTAP v2");
-            }
-        }
-    }
-
-    /// Handle a Bulk/Interrupt OUT transaction
-    ///
-    /// This is data going from the host to the device (us)
-    fn packet_out(
-        &'a self,
-        transfer_type: TransferType,
-        endpoint: usize,
-        packet_bytes: u32,
-    ) -> hil::usb::OutResult {
-        match transfer_type {
-            TransferType::Interrupt => {
-                self.recv_buffer
-                    .take()
-                    .map_or(hil::usb::OutResult::Error, |buf| {
-                        let recv_offset = self.recv_offset.get();
-
-                        // How many more bytes can we store in our RX buffer?
-                        let available_bytes = buf.len() - recv_offset;
-                        let copy_length = cmp::min(packet_bytes as usize, available_bytes);
-
-                        // Do the copy into the RX buffer.
-                        let packet = &self.buffers[OUT_BUFFER].buf;
-                        for i in 0..copy_length {
-                            buf[recv_offset + i] = packet[i].get();
-                        }
-
-                        // Keep track of how many bytes we have received so far.
-                        let total_received_bytes = recv_offset + copy_length;
-
-                        // Update how many bytes we have gotten.
-                        self.recv_offset.set(total_received_bytes);
-
-                        // Check if we have received at least as many bytes as the
-                        // client asked for.
-                        if total_received_bytes >= self.recv_len.get() {
-                            if self.can_receive() {
-                                self.client.map(move |client| {
-                                    client.packet_received(Ok(()), buf, endpoint);
-                                });
-                                // Reset the offset
-                                self.recv_offset.set(0);
-                                // Delay the next packet until we have finished
-                                // processing this packet
-                                hil::usb::OutResult::Delay
-                            } else {
-                                // We can't receive data. Record that we have data to send later
-                                // and apply back pressure to USB
-                                self.saved_endpoint.set(endpoint);
-                                self.recv_buffer.replace(buf);
-                                hil::usb::OutResult::Delay
-                            }
-                        } else {
-                            // Make sure to put the RX buffer back.
-                            self.recv_buffer.replace(buf);
-                            hil::usb::OutResult::Ok
-                        }
-                    })
-            }
-            TransferType::Bulk | TransferType::Control | TransferType::Isochronous => {
-                panic!("Transfer protocol not supported by CTAP v2");
-            }
-        }
-    }
-
-    fn packet_transmitted(&'a self, endpoint: usize) {
-        self.send_buffer.take().map(|buf| {
-            self.client.map(move |client| {
-                client.packet_transmitted(Ok(()), buf, endpoint);
-            });
-        });
-    }
-}
diff --git a/capsules/src/usb/mod.rs b/capsules/src/usb/mod.rs
index 17cab4c23..3f3a4f646 100644
--- a/capsules/src/usb/mod.rs
+++ b/capsules/src/usb/mod.rs
@@ -1,5 +1,4 @@
 pub mod cdc;
-pub mod ctap;
 pub mod descriptors;
 pub mod usb_ctap;
 pub mod usb_user;
-- 
2.34.1


From c6bafdb5b57378adc8792a50d6b14e9c576c3b94 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Sun, 6 Nov 2022 17:21:54 +0100
Subject: [PATCH 04/27] Add 09-add-vendor-hid-usb-interface.patch

---
 capsules/Cargo.toml                  |   3 +
 capsules/src/usb/descriptors.rs      |  17 ++--
 capsules/src/usb/usbc_client_ctrl.rs |  53 +++++++----
 capsules/src/usb/usbc_ctap_hid.rs    | 134 ++++++++++++++++++++++-----
 4 files changed, 157 insertions(+), 50 deletions(-)

diff --git a/capsules/Cargo.toml b/capsules/Cargo.toml
index c04b2e0f3..09d2df2a3 100644
--- a/capsules/Cargo.toml
+++ b/capsules/Cargo.toml
@@ -8,3 +8,6 @@ edition.workspace = true
 kernel = { path = "../kernel" }
 enum_primitive = { path = "../libraries/enum_primitive" }
 tickv = { path = "../libraries/tickv" }
+
+[features]
+vendor_hid = []
diff --git a/capsules/src/usb/descriptors.rs b/capsules/src/usb/descriptors.rs
index 67f708239..c2556d3a2 100644
--- a/capsules/src/usb/descriptors.rs
+++ b/capsules/src/usb/descriptors.rs
@@ -415,13 +415,14 @@ impl DescriptorBuffer {
 /// example, if the interface descriptor list contains `[ID1, ID2, ID3]`,
 /// and the endpoint descriptors list is `[[ED1, ED2], [ED3, ED4, ED5],
 /// [ED6]]`, then the third interface descriptor (`ID3`) has one
-/// corresponding endpoint descriptor (`ED6`).
+/// corresponding endpoint descriptor (`ED6`). If supplied, each HID descriptor
+/// corresponds to the matching index in the interface descriptor list.
 pub fn create_descriptor_buffers(
     device_descriptor: DeviceDescriptor,
     mut configuration_descriptor: ConfigurationDescriptor,
     interface_descriptor: &mut [InterfaceDescriptor],
     endpoint_descriptors: &[&[EndpointDescriptor]],
-    hid_descriptor: Option<&HIDDescriptor>,
+    hid_descriptor: Option<&[&HIDDescriptor<'static>]>,
     cdc_descriptor: Option<&[CdcInterfaceDescriptor]>,
 ) -> (DeviceBuffer, DescriptorBuffer) {
     // Create device descriptor buffer and fill.
@@ -505,7 +506,7 @@ pub fn create_descriptor_buffers(
                 .iter()
                 .map(|descs| descs.iter().map(|d| d.size()).sum::<usize>())
                 .sum::<usize>()
-            + hid_descriptor.map_or(0, |d| d.size())
+            + hid_descriptor.map_or(0, |ds| ds.iter().map(|d| d.size()).sum::<usize>())
             + cdc_descriptor.map_or(0, |ds| ds.iter().map(|d| d.size()).sum::<usize>());
 
     // Set the number of endpoints for each interface descriptor.
@@ -522,12 +523,10 @@ pub fn create_descriptor_buffers(
         // Add the interface descriptor.
         len += d.write_to(&other_buf.buf[len..]);
 
-        // If there is a HID descriptor, we include
-        // it with the first interface descriptor.
-        if i == 0 {
-            // HID descriptor, if any.
-            if let Some(dh) = hid_descriptor {
-                len += dh.write_to(&other_buf.buf[len..]);
+        // HID descriptor, if present, for this interface.
+        if let Some(dh) = hid_descriptor {
+            if let Some(d) = dh.get(i) {
+                len += d.write_to(&other_buf.buf[len..]);
             }
         }
 
diff --git a/capsules/src/usb/usbc_client_ctrl.rs b/capsules/src/usb/usbc_client_ctrl.rs
index c8e55a8a8..54c7c3bbb 100644
--- a/capsules/src/usb/usbc_client_ctrl.rs
+++ b/capsules/src/usb/usbc_client_ctrl.rs
@@ -40,6 +40,12 @@ const DESCRIPTOR_BUFLEN: usize = 128;
 
 const N_ENDPOINTS: usize = 3;
 
+#[cfg(feature = "vendor_hid")]
+const N_HID_INTERFACES: usize = 2;
+
+#[cfg(not(feature = "vendor_hid"))]
+const N_HID_INTERFACES: usize = 1;
+
 /// Handler for USB control endpoint requests.
 pub struct ClientCtrl<'a, 'b, U: 'a> {
     /// The USB hardware controller.
@@ -66,12 +72,12 @@ pub struct ClientCtrl<'a, 'b, U: 'a> {
 
     /// An optional HID descriptor for the configuration. This can be requested
     /// separately. It must also be included in `other_descriptor_buffer` if it exists.
-    hid_descriptor: Option<&'b HIDDescriptor<'b>>,
+    hid_descriptor: Option<[&'b HIDDescriptor<'b>; N_HID_INTERFACES]>,
 
     /// An optional report descriptor for the configuration. This can be
     /// requested separately. It must also be included in
     /// `other_descriptor_buffer` if it exists.
-    report_descriptor: Option<&'b ReportDescriptor<'b>>,
+    report_descriptor: Option<[&'b ReportDescriptor<'b>; N_HID_INTERFACES]>,
 
     /// Supported language (only one for now).
     language: &'b [u16; 1],
@@ -106,8 +112,8 @@ impl<'a, 'b, U: hil::usb::UsbController<'a>> ClientCtrl<'a, 'b, U> {
         controller: &'a U,
         device_descriptor_buffer: DeviceBuffer,
         other_descriptor_buffer: DescriptorBuffer,
-        hid_descriptor: Option<&'b HIDDescriptor<'b>>,
-        report_descriptor: Option<&'b ReportDescriptor<'b>>,
+        hid_descriptor: Option<[&'b HIDDescriptor<'b>; N_HID_INTERFACES]>,
+        report_descriptor: Option<[&'b ReportDescriptor<'b>; N_HID_INTERFACES]>,
         language: &'b [u16; 1],
         strings: &'b [&'b str],
     ) -> Self {
@@ -333,28 +339,39 @@ impl<'a, 'b, U: hil::usb::UsbController<'a>> ClientCtrl<'a, 'b, U> {
                 descriptor_type,
                 // TODO: use the descriptor index
                 descriptor_index: _,
-                // TODO: use the language ID?
-                lang_id: _,
+                lang_id,
                 requested_length,
             } => match descriptor_type {
                 DescriptorType::HID => {
-                    if let Some(desc) = self.hid_descriptor {
-                        let buf = self.descriptor_buf();
-                        let len = desc.write_to(buf);
-                        let end = min(len, requested_length as usize);
-                        self.state[endpoint].set(State::CtrlIn(0, end));
-                        hil::usb::CtrlSetupResult::Ok
+                    if let Some(dh) = self.hid_descriptor {
+                        let interface = lang_id as usize;
+                        if interface < dh.len() {
+                            let d = dh[interface];
+                            let buf = self.descriptor_buf();
+                            let len = d.write_to(buf);
+                            let end = min(len, requested_length as usize);
+                            self.state[endpoint].set(State::CtrlIn(0, end));
+                            hil::usb::CtrlSetupResult::Ok
+                        } else {
+                            hil::usb::CtrlSetupResult::ErrGeneric
+                        }
                     } else {
                         hil::usb::CtrlSetupResult::ErrGeneric
                     }
                 }
                 DescriptorType::Report => {
-                    if let Some(desc) = self.report_descriptor {
-                        let buf = self.descriptor_buf();
-                        let len = desc.write_to(buf);
-                        let end = min(len, requested_length as usize);
-                        self.state[endpoint].set(State::CtrlIn(0, end));
-                        hil::usb::CtrlSetupResult::Ok
+                    if let Some(desc_array) = self.report_descriptor {
+                        let interface = lang_id as usize;
+                        if interface < desc_array.len() {
+                            let desc = desc_array[interface];
+                            let buf = self.descriptor_buf();
+                            let len = desc.write_to(buf);
+                            let end = min(len, requested_length as usize);
+                            self.state[endpoint].set(State::CtrlIn(0, end));
+                            hil::usb::CtrlSetupResult::Ok
+                        } else {
+                            hil::usb::CtrlSetupResult::ErrGeneric
+                        }
                     } else {
                         hil::usb::CtrlSetupResult::ErrGeneric
                     }
diff --git a/capsules/src/usb/usbc_ctap_hid.rs b/capsules/src/usb/usbc_ctap_hid.rs
index eeaa99e0b..dd53fd272 100644
--- a/capsules/src/usb/usbc_ctap_hid.rs
+++ b/capsules/src/usb/usbc_ctap_hid.rs
@@ -44,21 +44,60 @@ static CTAP_REPORT_DESCRIPTOR: &'static [u8] = &[
     0xC0, // HID_EndCollection
 ];
 
+#[cfg(feature = "vendor_hid")]
+static VENDOR_REPORT_DESCRIPTOR: &'static [u8] = &[
+    0x06, 0x00, 0xFF, // HID_UsagePage ( VENDOR ),
+    0x09, 0x01, // HID_Usage ( Unused ),
+    0xA1, 0x01, // HID_Collection ( HID_Application ),
+    0x09, 0x20, // HID_Usage ( FIDO_USAGE_DATA_IN ),
+    0x15, 0x00, // HID_LogicalMin ( 0 ),
+    0x26, 0xFF, 0x00, // HID_LogicalMaxS ( 0xff ),
+    0x75, 0x08, // HID_ReportSize ( 8 ),
+    0x95, 0x40, // HID_ReportCount ( HID_INPUT_REPORT_BYTES ),
+    0x81, 0x02, // HID_Input ( HID_Data | HID_Absolute | HID_Variable ),
+    0x09, 0x21, // HID_Usage ( FIDO_USAGE_DATA_OUT ),
+    0x15, 0x00, // HID_LogicalMin ( 0 ),
+    0x26, 0xFF, 0x00, // HID_LogicalMaxS ( 0xff ),
+    0x75, 0x08, // HID_ReportSize ( 8 ),
+    0x95, 0x40, // HID_ReportCount ( HID_OUTPUT_REPORT_BYTES ),
+    0x91, 0x02, // HID_Output ( HID_Data | HID_Absolute | HID_Variable ),
+    0xC0, // HID_EndCollection
+];
+
 static CTAP_REPORT: ReportDescriptor<'static> = ReportDescriptor {
     desc: CTAP_REPORT_DESCRIPTOR,
 };
 
+#[cfg(feature = "vendor_hid")]
+static VENDOR_REPORT: ReportDescriptor<'static> = ReportDescriptor {
+    desc: VENDOR_REPORT_DESCRIPTOR,
+};
+
 static HID_SUB_DESCRIPTORS: &'static [HIDSubordinateDescriptor] = &[HIDSubordinateDescriptor {
     typ: DescriptorType::Report,
     len: CTAP_REPORT_DESCRIPTOR.len() as u16,
 }];
 
+#[cfg(feature = "vendor_hid")]
+static VENDOR_HID_SUB_DESCRIPTORS: &'static [HIDSubordinateDescriptor] =
+    &[HIDSubordinateDescriptor {
+        typ: DescriptorType::Report,
+        len: VENDOR_REPORT_DESCRIPTOR.len() as u16,
+    }];
+
 static HID: HIDDescriptor<'static> = HIDDescriptor {
     hid_class: 0x0110,
     country_code: HIDCountryCode::NotSupported,
     sub_descriptors: HID_SUB_DESCRIPTORS,
 };
 
+#[cfg(feature = "vendor_hid")]
+static VENDOR_HID: HIDDescriptor<'static> = HIDDescriptor {
+    hid_class: 0x0110,
+    country_code: HIDCountryCode::NotSupported,
+    sub_descriptors: VENDOR_HID_SUB_DESCRIPTORS,
+};
+
 pub struct ClientCtapHID<'a, 'b, C: 'a> {
     client_ctrl: ClientCtrl<'a, 'static, C>,
 
@@ -82,6 +121,9 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
         product_id: u16,
         strings: &'static [&'static str],
     ) -> Self {
+        #[cfg(feature = "vendor_hid")]
+        debug!("vendor_hid enabled.");
+
         let interfaces: &mut [InterfaceDescriptor] = &mut [
             // Interface declared in the FIDO2 specification, section 8.1.8.1
             InterfaceDescriptor {
@@ -90,28 +132,62 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
                 interface_protocol: 0x00,
                 ..InterfaceDescriptor::default()
             },
+            // Vendor HID interface.
+            #[cfg(feature = "vendor_hid")]
+            InterfaceDescriptor {
+                interface_number: 1,
+                interface_class: 0x03, // HID
+                interface_subclass: 0x00,
+                interface_protocol: 0x00,
+                ..InterfaceDescriptor::default()
+            },
         ];
 
-        let endpoints: &[&[EndpointDescriptor]] = &[&[
-            EndpointDescriptor {
-                endpoint_address: EndpointAddress::new_const(
-                    ENDPOINT_NUM,
-                    TransferDirection::HostToDevice,
-                ),
-                transfer_type: TransferType::Interrupt,
-                max_packet_size: 64,
-                interval: 5,
-            },
-            EndpointDescriptor {
-                endpoint_address: EndpointAddress::new_const(
-                    ENDPOINT_NUM,
-                    TransferDirection::DeviceToHost,
-                ),
-                transfer_type: TransferType::Interrupt,
-                max_packet_size: 64,
-                interval: 5,
-            },
-        ]];
+        let endpoints: &[&[EndpointDescriptor]] = &[
+            &[
+                // 2 Endpoints for FIDO
+                EndpointDescriptor {
+                    endpoint_address: EndpointAddress::new_const(
+                        ENDPOINT_NUM,
+                        TransferDirection::HostToDevice,
+                    ),
+                    transfer_type: TransferType::Interrupt,
+                    max_packet_size: 64,
+                    interval: 5,
+                },
+                EndpointDescriptor {
+                    endpoint_address: EndpointAddress::new_const(
+                        ENDPOINT_NUM,
+                        TransferDirection::DeviceToHost,
+                    ),
+                    transfer_type: TransferType::Interrupt,
+                    max_packet_size: 64,
+                    interval: 5,
+                },
+            ],
+            // 2 Endpoints for FIDO
+            #[cfg(feature = "vendor_hid")]
+            &[
+                EndpointDescriptor {
+                    endpoint_address: EndpointAddress::new_const(
+                        ENDPOINT_NUM + 1,
+                        TransferDirection::HostToDevice,
+                    ),
+                    transfer_type: TransferType::Interrupt,
+                    max_packet_size: 64,
+                    interval: 5,
+                },
+                EndpointDescriptor {
+                    endpoint_address: EndpointAddress::new_const(
+                        ENDPOINT_NUM + 1,
+                        TransferDirection::DeviceToHost,
+                    ),
+                    transfer_type: TransferType::Interrupt,
+                    max_packet_size: 64,
+                    interval: 5,
+                },
+            ],
+        ];
 
         let (device_descriptor_buffer, other_descriptor_buffer) =
             descriptors::create_descriptor_buffers(
@@ -130,7 +206,11 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
                 },
                 interfaces,
                 endpoints,
-                Some(&HID),
+                Some(&[
+                    &HID,
+                    #[cfg(feature = "vendor_hid")]
+                    &VENDOR_HID,
+                ]),
                 None, // No CDC descriptor array
             );
 
@@ -139,8 +219,16 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
                 controller,
                 device_descriptor_buffer,
                 other_descriptor_buffer,
-                Some(&HID),
-                Some(&CTAP_REPORT),
+                Some([
+                    &HID,
+                    #[cfg(feature = "vendor_hid")]
+                    &VENDOR_HID,
+                ]),
+                Some([
+                    &CTAP_REPORT,
+                    #[cfg(feature = "vendor_hid")]
+                    &VENDOR_REPORT,
+                ]),
                 LANGUAGES,
                 strings,
             ),
-- 
2.34.1


From 088a745de9d1d1b2613e32945ddd9752bb988555 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Sun, 6 Nov 2022 18:38:23 +0100
Subject: [PATCH 05/27] Add 10-avoid-app-reentry.patch

This can be combined with the usb patch as it moves some stuff around.
---
 capsules/src/usb/app.rs           |  61 +++++++++++++
 capsules/src/usb/mod.rs           |   1 +
 capsules/src/usb/usb_ctap.rs      | 140 ++++++++++--------------------
 capsules/src/usb/usbc_ctap_hid.rs |  13 +--
 4 files changed, 115 insertions(+), 100 deletions(-)
 create mode 100644 capsules/src/usb/app.rs

diff --git a/capsules/src/usb/app.rs b/capsules/src/usb/app.rs
new file mode 100644
index 000000000..f2e248bc9
--- /dev/null
+++ b/capsules/src/usb/app.rs
@@ -0,0 +1,61 @@
+#[derive(Clone, Copy, PartialEq, Eq)]
+pub enum Side {
+    Transmit,
+    Receive,
+    TransmitOrReceive,
+}
+
+impl Side {
+    pub fn can_transmit(&self) -> bool {
+        match self {
+            Side::Transmit | Side::TransmitOrReceive => true,
+            Side::Receive => false,
+        }
+    }
+
+    pub fn can_receive(&self) -> bool {
+        match self {
+            Side::Receive | Side::TransmitOrReceive => true,
+            Side::Transmit => false,
+        }
+    }
+}
+
+#[derive(Default)]
+pub struct App {
+    // Only one app can be connected to this driver, to avoid needing to route packets among apps.
+    // This field tracks this status.
+    pub connected: bool,
+    // Currently enabled transaction side. Subscribing to a callback or allowing a buffer
+    // automatically sets the corresponding side. Clearing both the callback and the buffer resets
+    // the side to None.
+    pub side: Option<Side>,
+    // Whether the app is waiting for the kernel signaling a packet transfer.
+    pub waiting: bool,
+}
+
+impl App {
+    pub fn can_receive_packet(&self) -> bool {
+        self.waiting && self.side.map_or(false, |side| side.can_receive())
+    }
+
+    pub fn check_side(&mut self) {
+        if !self.waiting {
+            self.side = None;
+        }
+    }
+
+    pub fn set_side(&mut self, side: Side) -> bool {
+        match self.side {
+            None => {
+                self.side = Some(side);
+                true
+            }
+            Some(app_side) => side == app_side,
+        }
+    }
+
+    pub fn is_ready_for_command(&self, side: Side) -> bool {
+        self.side == Some(side)
+    }
+}
diff --git a/capsules/src/usb/mod.rs b/capsules/src/usb/mod.rs
index 3f3a4f646..cb5e0af97 100644
--- a/capsules/src/usb/mod.rs
+++ b/capsules/src/usb/mod.rs
@@ -1,3 +1,4 @@
+pub mod app;
 pub mod cdc;
 pub mod descriptors;
 pub mod usb_ctap;
diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index 308ab5d51..6c24c8f16 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -1,6 +1,7 @@
+use super::app::{App, Side};
 use super::usbc_ctap_hid::ClientCtapHID;
 use kernel::errorcode::ErrorCode;
-use kernel::grant::{AllowRoCount, AllowRwCount, Grant, UpcallCount};
+use kernel::grant::{AllowRoCount, AllowRwCount, Grant, GrantKernelData, UpcallCount};
 use kernel::hil;
 use kernel::hil::usb::Client;
 use kernel::processbuffer::{ReadableProcessBuffer, WriteableProcessBuffer};
@@ -35,71 +36,15 @@ pub const CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM: usize = 1;
 
 type CtabUsbDriverGrant = Grant<App, UpcallCount<2>, AllowRoCount<1>, AllowRwCount<1>>;
 
-#[derive(Clone, Copy, PartialEq, Eq)]
-enum Side {
-    Transmit,
-    Receive,
-    TransmitOrReceive,
-}
-
-impl Side {
-    fn can_transmit(&self) -> bool {
-        match self {
-            Side::Transmit | Side::TransmitOrReceive => true,
-            Side::Receive => false,
-        }
-    }
-
-    fn can_receive(&self) -> bool {
-        match self {
-            Side::Receive | Side::TransmitOrReceive => true,
-            Side::Transmit => false,
-        }
-    }
-}
-
-#[derive(Default)]
-pub struct App {
-    // Only one app can be connected to this driver, to avoid needing to route packets among apps.
-    // This field tracks this status.
-    connected: bool,
-    // Currently enabled transaction side. Subscribing to a callback or allowing a buffer
-    // automatically sets the corresponding side. Clearing both the callback and the buffer resets
-    // the side to None.
-    side: Option<Side>,
-    // Whether the app is waiting for the kernel signaling a packet transfer.
-    waiting: bool,
-}
-
-impl App {
-    fn check_side(&mut self) {
-        if !self.waiting {
-            self.side = None;
-        }
-    }
-
-    fn set_side(&mut self, side: Side) -> bool {
-        match self.side {
-            None => {
-                self.side = Some(side);
-                true
-            }
-            Some(app_side) => side == app_side,
-        }
-    }
-
-    fn is_ready_for_command(&self, side: Side) -> bool {
-        self.side == Some(side)
-    }
-}
-
 pub trait CtapUsbClient {
     // Whether this client is ready to receive a packet. This must be checked before calling
-    // packet_received().
-    fn can_receive_packet(&self) -> bool;
+    // packet_received(). If App is not supplied, it will be found from the implemntation's
+    // members.
+    fn can_receive_packet(&self, app: &Option<&mut App>) -> bool;
 
     // Signal to the client that a packet has been received.
-    fn packet_received(&self, packet: &[u8; 64]);
+    // If App is not supplied, it will be found from the implementation's members.
+    fn packet_received(&self, packet: &[u8; 64], app: Option<&mut App>);
 
     // Signal to the client that a packet has been transmitted.
     fn packet_transmitted(&self);
@@ -114,47 +59,54 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbSyscallDriver<'a, 'b, C> {
     pub fn new(usb_client: &'a ClientCtapHID<'a, 'b, C>, apps: CtabUsbDriverGrant) -> Self {
         CtapUsbSyscallDriver { usb_client, apps }
     }
+
+    fn app_packet_received(&self, packet: &[u8; 64], app: &mut App, kernel_data: &GrantKernelData) {
+        if app.connected && app.waiting && app.side.map_or(false, |side| side.can_receive()) {
+            kernel_data
+                .get_readwrite_processbuffer(1)
+                .and_then(|process_buffer| {
+                    process_buffer
+                        .mut_enter(|buf| buf.copy_from_slice(packet))
+                        .unwrap();
+                    app.waiting = false;
+                    // Signal to the app that a packet is ready.
+                    kernel_data
+                        .schedule_upcall(CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM, (0, 0, 0))
+                        .unwrap();
+                    // reset the client state
+                    app.check_side();
+
+                    Ok(())
+                })
+                .unwrap();
+        }
+    }
 }
 
 impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDriver<'a, 'b, C> {
-    fn can_receive_packet(&self) -> bool {
+    fn can_receive_packet(&self, app: &Option<&mut App>) -> bool {
         let mut result = false;
-        for app in self.apps.iter() {
-            app.enter(|app, _| {
-                if app.connected {
-                    result = app.waiting && app.side.map_or(false, |side| side.can_receive());
+        match app {
+            None => {
+                for app in self.apps.iter() {
+                    app.enter(|a, _| {
+                        if a.connected {
+                            result = a.can_receive_packet();
+                        }
+                    })
                 }
-            });
+            }
+            Some(a) => result = a.can_receive_packet(),
         }
         result
     }
 
-    fn packet_received(&self, packet: &[u8; 64]) {
+    // TODO: interface weird. we need the reentry to get the kernel data
+    fn packet_received(&self, packet: &[u8; 64], _app: Option<&mut App>) {
         for app in self.apps.iter() {
-            app.enter(|app, kernel_data| {
-                if app.connected && app.waiting && app.side.map_or(false, |side| side.can_receive())
-                {
-                    kernel_data
-                        .get_readwrite_processbuffer(1)
-                        .and_then(|process_buffer| {
-                            process_buffer
-                                .mut_enter(|buf| buf.copy_from_slice(packet))
-                                .unwrap();
-                            app.waiting = false;
-                            // Signal to the app that a packet is ready.
-                            kernel_data
-                                .schedule_upcall(CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM, (0, 0, 0))
-                                .unwrap();
-                            // reset the client state
-                            app.check_side();
-
-                            Ok(())
-                        })
-                } else {
-                    Err(kernel::process::Error::KernelError)
-                }
+            app.enter(|a, kernel_data| {
+                self.app_packet_received(packet, a, kernel_data);
             })
-            .unwrap();
         }
     }
 
@@ -269,7 +221,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                                 CommandReturn::failure(ErrorCode::ALREADY)
                             } else {
                                 app.waiting = true;
-                                self.usb_client.receive_packet();
+                                self.usb_client.receive_packet(app);
                                 CommandReturn::success()
                             }
                         } else {
@@ -295,7 +247,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                             } else {
                                 // Indicates to the driver that we can receive any pending packet.
                                 app.waiting = true;
-                                self.usb_client.receive_packet();
+                                self.usb_client.receive_packet(app);
 
                                 if !app.waiting {
                                     // The call to receive_packet() collected a pending packet.
diff --git a/capsules/src/usb/usbc_ctap_hid.rs b/capsules/src/usb/usbc_ctap_hid.rs
index dd53fd272..cdae85ae7 100644
--- a/capsules/src/usb/usbc_ctap_hid.rs
+++ b/capsules/src/usb/usbc_ctap_hid.rs
@@ -1,5 +1,6 @@
 //! A USB HID client of the USB hardware interface
 
+use super::app::App;
 use super::descriptors;
 use super::descriptors::Buffer64;
 use super::descriptors::DescriptorType;
@@ -261,7 +262,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
         }
     }
 
-    pub fn receive_packet(&'a self) -> bool {
+    pub fn receive_packet(&'a self, app: &mut App) -> bool {
         if self.pending_out.get() {
             // The previous packet has not yet been received, reject the new one.
             false
@@ -271,7 +272,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
             // Otherwise, there's nothing to do, the controller will send us a packet_out when a
             // packet arrives.
             if self.delayed_out.take() {
-                if self.send_packet_to_client() {
+                if self.send_packet_to_client(Some(app)) {
                     // If that succeeds, alert the controller that we can now
                     // receive data on the Interrupt OUT endpoint.
                     self.controller().endpoint_resume_out(1);
@@ -284,7 +285,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
     // Send an OUT packet available in the controller back to the client.
     // This returns false if the client is not ready to receive a packet, and true if the client
     // successfully accepted the packet.
-    fn send_packet_to_client(&'a self) -> bool {
+    fn send_packet_to_client(&'a self, app: Option<&mut App>) -> bool {
         // Copy the packet into a buffer to send to the client.
         let mut buf: [u8; 64] = [0; 64];
         for (i, x) in self.out_buffer.buf.iter().enumerate() {
@@ -296,7 +297,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
         // Notify the client
         if self
             .client
-            .map_or(false, |client| client.can_receive_packet())
+            .map_or(false, |client| client.can_receive_packet(&app))
         {
             assert!(self.pending_out.take());
 
@@ -305,7 +306,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
             // should be re-transmitted or not.
             self.cancel_in_transaction();
 
-            self.client.map(|client| client.packet_received(&buf));
+            self.client.map(|client| client.packet_received(&buf, app));
             true
         } else {
             // Cannot receive now, indicate a delay to the controller.
@@ -425,7 +426,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
                     // Cannot process this packet
                     hil::usb::OutResult::Error
                 } else {
-                    if self.send_packet_to_client() {
+                    if self.send_packet_to_client(None) {
                         hil::usb::OutResult::Ok
                     } else {
                         hil::usb::OutResult::Delay
-- 
2.34.1


From ee10493e82da36fe69c0434e0998497b8ca6e95e Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Mon, 7 Nov 2022 19:21:41 +0100
Subject: [PATCH 06/27] Add 11-connect-vendor-hid-usb-interface.patch

This can also be combined with the previous USB patches since it changes
mainly the programming interface.
---
 capsules/src/usb/usb_ctap.rs      |  37 ++--
 capsules/src/usb/usbc_ctap_hid.rs | 283 +++++++++++++++++++-----------
 kernel/src/syscall_driver.rs      |  13 ++
 3 files changed, 211 insertions(+), 122 deletions(-)

diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index 6c24c8f16..bf0b5bf4e 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -43,8 +43,7 @@ pub trait CtapUsbClient {
     fn can_receive_packet(&self, app: &Option<&mut App>) -> bool;
 
     // Signal to the client that a packet has been received.
-    // If App is not supplied, it will be found from the implementation's members.
-    fn packet_received(&self, packet: &[u8; 64], app: Option<&mut App>);
+    fn packet_received(&self, packet: &[u8; 64], endpoint: usize, app: Option<&mut App>);
 
     // Signal to the client that a packet has been transmitted.
     fn packet_transmitted(&self);
@@ -60,7 +59,13 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbSyscallDriver<'a, 'b, C> {
         CtapUsbSyscallDriver { usb_client, apps }
     }
 
-    fn app_packet_received(&self, packet: &[u8; 64], app: &mut App, kernel_data: &GrantKernelData) {
+    fn app_packet_received(
+        &self,
+        packet: &[u8; 64],
+        endpoint: usize,
+        app: &mut App,
+        kernel_data: &GrantKernelData,
+    ) {
         if app.connected && app.waiting && app.side.map_or(false, |side| side.can_receive()) {
             kernel_data
                 .get_readwrite_processbuffer(1)
@@ -71,7 +76,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbSyscallDriver<'a, 'b, C> {
                     app.waiting = false;
                     // Signal to the app that a packet is ready.
                     kernel_data
-                        .schedule_upcall(CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM, (0, 0, 0))
+                        .schedule_upcall(CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM, (endpoint, 0, 0))
                         .unwrap();
                     // reset the client state
                     app.check_side();
@@ -102,10 +107,10 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDri
     }
 
     // TODO: interface weird. we need the reentry to get the kernel data
-    fn packet_received(&self, packet: &[u8; 64], _app: Option<&mut App>) {
+    fn packet_received(&self, packet: &[u8; 64], endpoint: usize, _app: Option<&mut App>) {
         for app in self.apps.iter() {
             app.enter(|a, kernel_data| {
-                self.app_packet_received(packet, a, kernel_data);
+                self.app_packet_received(packet, endpoint, a, kernel_data);
             })
         }
     }
@@ -139,7 +144,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
     fn command(
         &self,
         cmd_num: usize,
-        _arg1: usize,
+        endpoint: usize,
         _arg2: usize,
         process_id: ProcessId,
     ) -> CommandReturn {
@@ -190,12 +195,14 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                                         buffer.enter(|buf| {
                                             let mut packet: [u8; 64] = [0; 64];
                                             buf.copy_to_slice(&mut packet);
-                                            if self.usb_client.transmit_packet(&packet) {
+                                            let r =
+                                                self.usb_client.transmit_packet(&packet, endpoint);
+
+                                            if r.is_success() {
                                                 app.waiting = true;
-                                                CommandReturn::success()
-                                            } else {
-                                                CommandReturn::failure(ErrorCode::BUSY)
                                             }
+
+                                            r
                                         })
                                     })
                                     .unwrap_or(CommandReturn::failure(ErrorCode::FAIL))
@@ -261,11 +268,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                                                 buf.copy_to_slice(&mut packet);
 
                                                 // Indicates to the driver that we have a packet to send.
-                                                if self.usb_client.transmit_packet(&packet) {
-                                                    CommandReturn::success()
-                                                } else {
-                                                    CommandReturn::failure(ErrorCode::BUSY)
-                                                }
+                                                self.usb_client.transmit_packet(&packet, endpoint)
                                             })
                                         })
                                         .unwrap_or(CommandReturn::failure(ErrorCode::FAIL))
@@ -287,7 +290,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                             // FIXME: if cancellation failed, the app should still wait. But that
                             // doesn't work yet.
                             app.waiting = false;
-                            if self.usb_client.cancel_transaction() {
+                            if self.usb_client.cancel_transaction(endpoint) {
                                 CommandReturn::success()
                             } else {
                                 // Cannot cancel now because the transaction is already in process.
diff --git a/capsules/src/usb/usbc_ctap_hid.rs b/capsules/src/usb/usbc_ctap_hid.rs
index cdae85ae7..2b1c4dd1b 100644
--- a/capsules/src/usb/usbc_ctap_hid.rs
+++ b/capsules/src/usb/usbc_ctap_hid.rs
@@ -18,13 +18,27 @@ use core::cell::Cell;
 use kernel::debug;
 use kernel::hil;
 use kernel::hil::usb::TransferType;
+use kernel::syscall::CommandReturn;
 use kernel::utilities::cells::OptionalCell;
 
 static LANGUAGES: &'static [u16; 1] = &[
     0x0409, // English (United States)
 ];
 
+#[cfg(not(feature = "vendor_hid"))]
+const NUM_ENDPOINTS: usize = 1;
+#[cfg(feature = "vendor_hid")]
+const NUM_ENDPOINTS: usize = 2;
+
 const ENDPOINT_NUM: usize = 1;
+#[cfg(feature = "vendor_hid")]
+const VENDOR_ENDPOINT_NUM: usize = ENDPOINT_NUM + 1;
+
+static ENDPOINTS: &'static [usize] = &[
+    ENDPOINT_NUM,
+    #[cfg(feature = "vendor_hid")]
+    VENDOR_ENDPOINT_NUM,
+];
 
 static CTAP_REPORT_DESCRIPTOR: &'static [u8] = &[
     0x06, 0xD0, 0xF1, // HID_UsagePage ( FIDO_USAGE_PAGE ),
@@ -99,21 +113,41 @@ static VENDOR_HID: HIDDescriptor<'static> = HIDDescriptor {
     sub_descriptors: VENDOR_HID_SUB_DESCRIPTORS,
 };
 
-pub struct ClientCtapHID<'a, 'b, C: 'a> {
-    client_ctrl: ClientCtrl<'a, 'static, C>,
-
-    // 64-byte buffers for the endpoint
+/// The state of each endpoint
+struct EndpointState {
+    endpoint: usize,
     in_buffer: Buffer64,
     out_buffer: Buffer64,
-
-    // Interaction with the client
-    client: OptionalCell<&'b dyn CtapUsbClient>,
     tx_packet: OptionalCell<[u8; 64]>,
     pending_in: Cell<bool>,
     pending_out: Cell<bool>,
+    /// Is there a delayed packet?
     delayed_out: Cell<bool>,
 }
 
+impl EndpointState {
+    pub fn new(endpoint: usize) -> Self {
+        EndpointState {
+            endpoint: endpoint,
+            in_buffer: Buffer64::default(),
+            out_buffer: Buffer64::default(),
+            tx_packet: OptionalCell::empty(),
+            pending_in: Cell::new(false),
+            pending_out: Cell::new(false),
+            delayed_out: Cell::new(false),
+        }
+    }
+}
+
+pub struct ClientCtapHID<'a, 'b, C: 'a> {
+    client_ctrl: ClientCtrl<'a, 'static, C>,
+
+    endpoints: [EndpointState; NUM_ENDPOINTS],
+
+    /// Interaction with the client
+    client: OptionalCell<&'b dyn CtapUsbClient>,
+}
+
 impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
     pub fn new(
         controller: &'a C,
@@ -171,7 +205,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
             &[
                 EndpointDescriptor {
                     endpoint_address: EndpointAddress::new_const(
-                        ENDPOINT_NUM + 1,
+                        VENDOR_ENDPOINT_NUM,
                         TransferDirection::HostToDevice,
                     ),
                     transfer_type: TransferType::Interrupt,
@@ -180,7 +214,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
                 },
                 EndpointDescriptor {
                     endpoint_address: EndpointAddress::new_const(
-                        ENDPOINT_NUM + 1,
+                        VENDOR_ENDPOINT_NUM,
                         TransferDirection::DeviceToHost,
                     ),
                     transfer_type: TransferType::Interrupt,
@@ -233,99 +267,136 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
                 LANGUAGES,
                 strings,
             ),
-            in_buffer: Buffer64::default(),
-            out_buffer: Buffer64::default(),
+            endpoints: [
+                EndpointState::new(ENDPOINT_NUM),
+                #[cfg(feature = "vendor_hid")]
+                EndpointState::new(VENDOR_ENDPOINT_NUM),
+            ],
             client: OptionalCell::empty(),
-            tx_packet: OptionalCell::empty(),
-            pending_in: Cell::new(false),
-            pending_out: Cell::new(false),
-            delayed_out: Cell::new(false),
         }
     }
 
+    fn get_endpoint(&'a self, endpoint: usize) -> Option<&'a EndpointState> {
+        for (i, ep) in ENDPOINTS.iter().enumerate() {
+            if endpoint == *ep {
+                return Some(&self.endpoints[i]);
+            }
+        }
+        None
+    }
+
     pub fn set_client(&'a self, client: &'b dyn CtapUsbClient) {
         self.client.set(client);
     }
 
-    pub fn transmit_packet(&'a self, packet: &[u8]) -> bool {
-        if self.pending_in.get() {
-            // The previous packet has not yet been transmitted, reject the new one.
-            false
-        } else {
-            self.pending_in.set(true);
+    pub fn transmit_packet(&'a self, packet: &[u8], endpoint: usize) -> CommandReturn {
+        if let Some(s) = self.get_endpoint(endpoint) {
+            if s.pending_in.get() {
+                // The previous packet has not yet been transmitted, reject the new one.
+                return CommandReturn::failure(kernel::ErrorCode::BUSY);
+            }
+            s.pending_in.set(true);
             let mut buf: [u8; 64] = [0; 64];
             buf.copy_from_slice(packet);
-            self.tx_packet.set(buf);
+            s.tx_packet.set(buf);
             // Alert the controller that we now have data to send on the Interrupt IN endpoint.
-            self.controller().endpoint_resume_in(1);
-            true
+            self.controller().endpoint_resume_in(endpoint);
+            CommandReturn::success()
+        } else {
+            // unsupported endpoint
+            CommandReturn::failure(kernel::ErrorCode::INVAL)
         }
     }
 
-    pub fn receive_packet(&'a self, app: &mut App) -> bool {
-        if self.pending_out.get() {
-            // The previous packet has not yet been received, reject the new one.
-            false
-        } else {
-            self.pending_out.set(true);
-            // In case we reported Delay before, send the pending packet back to the client.
-            // Otherwise, there's nothing to do, the controller will send us a packet_out when a
-            // packet arrives.
-            if self.delayed_out.take() {
-                if self.send_packet_to_client(Some(app)) {
-                    // If that succeeds, alert the controller that we can now
-                    // receive data on the Interrupt OUT endpoint.
-                    self.controller().endpoint_resume_out(1);
+    pub fn receive_packet(&'a self, app: &mut App) {
+        for (_, s) in self.endpoints.iter().enumerate() {
+            if s.pending_out.get() {
+                // The previous packet has not yet been received, reject the new one.
+                continue;
+            } else {
+                s.pending_out.set(true);
+                // In case we reported Delay before, send the pending packet back to the client.
+                // Otherwise, there's nothing to do, the controller will send us a packet_out when a
+                // packet arrives.
+                if s.delayed_out.take() {
+                    if self.send_packet_to_client(s.endpoint, Some(app)) {
+                        // If that succeeds, alert the controller that we can now
+                        // receive data on the Interrupt OUT endpoint.
+                        self.controller().endpoint_resume_out(s.endpoint);
+                    }
                 }
             }
-            true
         }
     }
 
     // Send an OUT packet available in the controller back to the client.
     // This returns false if the client is not ready to receive a packet, and true if the client
     // successfully accepted the packet.
-    fn send_packet_to_client(&'a self, app: Option<&mut App>) -> bool {
-        // Copy the packet into a buffer to send to the client.
-        let mut buf: [u8; 64] = [0; 64];
-        for (i, x) in self.out_buffer.buf.iter().enumerate() {
-            buf[i] = x.get();
-        }
-
-        assert!(!self.delayed_out.get());
-
-        // Notify the client
-        if self
-            .client
-            .map_or(false, |client| client.can_receive_packet(&app))
-        {
-            assert!(self.pending_out.take());
-
-            // Clear any pending packet on the transmitting side.
-            // It's up to the client to handle the received packet and decide if this packet
-            // should be re-transmitted or not.
-            self.cancel_in_transaction();
+    fn send_packet_to_client(&'a self, endpoint: usize, app: Option<&mut App>) -> bool {
+        if let Some(s) = self.get_endpoint(endpoint) {
+            // Copy the packet into a buffer to send to the client.
+            let mut buf: [u8; 64] = [0; 64];
+            for (i, x) in s.out_buffer.buf.iter().enumerate() {
+                buf[i] = x.get();
+            }
 
-            self.client.map(|client| client.packet_received(&buf, app));
-            true
+            assert!(!s.delayed_out.get());
+
+            // Notify the client
+            if self
+                .client
+                .map_or(false, |client| client.can_receive_packet(&app))
+            {
+                assert!(s.pending_out.take());
+
+                // Clear any pending packet on the transmitting side.
+                // It's up to the client to handle the received packet and decide if this packet
+                // should be re-transmitted or not.
+                self.cancel_in_transaction(endpoint);
+
+                self.client
+                    .map(|client| client.packet_received(&buf, endpoint, app));
+                true
+            } else {
+                // Cannot receive now, indicate a delay to the controller.
+                s.delayed_out.set(true);
+                false
+            }
         } else {
-            // Cannot receive now, indicate a delay to the controller.
-            self.delayed_out.set(true);
+            // unsupported endpoint
             false
         }
     }
 
-    pub fn cancel_transaction(&'a self) -> bool {
-        self.cancel_in_transaction() | self.cancel_out_transaction()
+    /// Cancel transaction(s) in process. |endpoint| of 0 indicates all endpoints.
+    pub fn cancel_transaction(&'a self, endpoint: usize) -> bool {
+        if endpoint > 0 {
+            return self.cancel_in_transaction(endpoint) | self.cancel_out_transaction(endpoint);
+        }
+        let mut r = false;
+        for (_, s) in self.endpoints.iter().enumerate() {
+            r |= self.cancel_in_transaction(s.endpoint) | self.cancel_out_transaction(s.endpoint);
+        }
+        r
     }
 
-    fn cancel_in_transaction(&'a self) -> bool {
-        self.tx_packet.take();
-        self.pending_in.take()
+    fn cancel_in_transaction(&'a self, endpoint: usize) -> bool {
+        if let Some(s) = self.get_endpoint(endpoint) {
+            s.tx_packet.take();
+            s.pending_in.take()
+        } else {
+            // Unsupported endpoint
+            false
+        }
     }
 
-    fn cancel_out_transaction(&'a self) -> bool {
-        self.pending_out.take()
+    fn cancel_out_transaction(&'a self, endpoint: usize) -> bool {
+        if let Some(s) = self.get_endpoint(endpoint) {
+            s.pending_out.take()
+        } else {
+            // Unsupported endpoint
+            false
+        }
     }
 
     #[inline]
@@ -339,13 +410,15 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
         // Set up the default control endpoint
         self.client_ctrl.enable();
 
-        // Set up the interrupt in-out endpoint
-        self.controller()
-            .endpoint_set_in_buffer(1, &self.in_buffer.buf);
-        self.controller()
-            .endpoint_set_out_buffer(1, &self.out_buffer.buf);
-        self.controller()
-            .endpoint_in_out_enable(TransferType::Interrupt, 1);
+        // Set up the interrupt in-out endpoint(s).
+        for (i, endpoint) in ENDPOINTS.iter().enumerate() {
+            self.controller()
+                .endpoint_set_in_buffer(*endpoint, &self.endpoints[i].in_buffer.buf);
+            self.controller()
+                .endpoint_set_out_buffer(*endpoint, &self.endpoints[i].out_buffer.buf);
+            self.controller()
+                .endpoint_in_out_enable(TransferType::Interrupt, *endpoint);
+        }
     }
 
     fn attach(&'a self) {
@@ -388,20 +461,20 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
         match transfer_type {
             TransferType::Bulk => hil::usb::InResult::Error,
             TransferType::Interrupt => {
-                if endpoint != 1 {
-                    return hil::usb::InResult::Error;
-                }
-
-                if let Some(packet) = self.tx_packet.take() {
-                    let buf = &self.in_buffer.buf;
-                    for i in 0..64 {
-                        buf[i].set(packet[i]);
+                if let Some(s) = self.get_endpoint(endpoint) {
+                    if let Some(packet) = s.tx_packet.take() {
+                        let buf = &s.in_buffer.buf;
+                        for i in 0..64 {
+                            buf[i].set(packet[i]);
+                        }
+                        hil::usb::InResult::Packet(64)
+                    } else {
+                        // Nothing to send
+                        hil::usb::InResult::Delay
                     }
-
-                    hil::usb::InResult::Packet(64)
                 } else {
-                    // Nothing to send
-                    hil::usb::InResult::Delay
+                    // Unsupported endpoint
+                    return hil::usb::InResult::Error;
                 }
             }
             TransferType::Control | TransferType::Isochronous => unreachable!(),
@@ -418,7 +491,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
         match transfer_type {
             TransferType::Bulk => hil::usb::OutResult::Error,
             TransferType::Interrupt => {
-                if endpoint != 1 {
+                if endpoint == 0 || endpoint > NUM_ENDPOINTS {
                     return hil::usb::OutResult::Error;
                 }
 
@@ -426,7 +499,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
                     // Cannot process this packet
                     hil::usb::OutResult::Error
                 } else {
-                    if self.send_packet_to_client(None) {
+                    if self.send_packet_to_client(endpoint, None) {
                         hil::usb::OutResult::Ok
                     } else {
                         hil::usb::OutResult::Delay
@@ -438,21 +511,21 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
     }
 
     fn packet_transmitted(&'a self, endpoint: usize) {
-        if endpoint != 1 {
-            panic!("Unexpected transmission on ep {}", endpoint);
-        }
-
-        if self.tx_packet.is_some() {
-            panic!("Unexpected tx_packet while a packet was being transmitted.");
-        }
-        self.pending_in.set(false);
+        if let Some(s) = self.get_endpoint(endpoint) {
+            if s.tx_packet.is_some() {
+                panic!("Unexpected tx_packet while a packet was being transmitted.");
+            }
+            s.pending_in.set(false);
 
-        // Clear any pending packet on the receiving side.
-        // It's up to the client to handle the transmitted packet and decide if they want to
-        // receive another packet.
-        self.cancel_out_transaction();
+            // Clear any pending packet on the receiving side.
+            // It's up to the client to handle the transmitted packet and decide if they want to
+            // receive another packet.
+            self.cancel_out_transaction(endpoint);
 
-        // Notify the client
-        self.client.map(|client| client.packet_transmitted());
+            // Notify the client
+            self.client.map(|client| client.packet_transmitted());
+        } else {
+            panic!("Unexpected transmission on ep {}", endpoint);
+        }
     }
 }
diff --git a/kernel/src/syscall_driver.rs b/kernel/src/syscall_driver.rs
index 0e2943fe4..3b5b42486 100644
--- a/kernel/src/syscall_driver.rs
+++ b/kernel/src/syscall_driver.rs
@@ -102,6 +102,19 @@ impl CommandReturn {
         self.0
     }
 
+    /// Check whether the inner `SyscallReturn` value is successful
+    pub fn is_success(&self) -> bool {
+        matches!(
+            self.0,
+            SyscallReturn::Success
+                | SyscallReturn::SuccessU32(_)
+                | SyscallReturn::SuccessU32U32(_, _)
+                | SyscallReturn::SuccessU32U32U32(_, _, _)
+                | SyscallReturn::SuccessU32U64(_, _)
+                | SyscallReturn::SuccessU64(_)
+        )
+    }
+
     /// Command error
     pub fn failure(rc: ErrorCode) -> Self {
         CommandReturn(SyscallReturn::Failure(rc))
-- 
2.34.1


From daf7e225fba98f93033b4ba6e66d3f2c335cb592 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Tue, 8 Nov 2022 18:00:40 +0100
Subject: [PATCH 07/27] Add 12-pending-deadlock.patch

---
 capsules/src/usb/usbc_ctap_hid.rs | 35 +++++++++++++++++++++----------
 1 file changed, 24 insertions(+), 11 deletions(-)

diff --git a/capsules/src/usb/usbc_ctap_hid.rs b/capsules/src/usb/usbc_ctap_hid.rs
index 2b1c4dd1b..e5ea9ecb2 100644
--- a/capsules/src/usb/usbc_ctap_hid.rs
+++ b/capsules/src/usb/usbc_ctap_hid.rs
@@ -120,7 +120,6 @@ struct EndpointState {
     out_buffer: Buffer64,
     tx_packet: OptionalCell<[u8; 64]>,
     pending_in: Cell<bool>,
-    pending_out: Cell<bool>,
     /// Is there a delayed packet?
     delayed_out: Cell<bool>,
 }
@@ -133,7 +132,6 @@ impl EndpointState {
             out_buffer: Buffer64::default(),
             tx_packet: OptionalCell::empty(),
             pending_in: Cell::new(false),
-            pending_out: Cell::new(false),
             delayed_out: Cell::new(false),
         }
     }
@@ -146,6 +144,10 @@ pub struct ClientCtapHID<'a, 'b, C: 'a> {
 
     /// Interaction with the client
     client: OptionalCell<&'b dyn CtapUsbClient>,
+
+    // Is there a pending OUT transaction happening?
+    pending_out: Cell<bool>,
+    next_endpoint_index: Cell<usize>,
 }
 
 impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
@@ -267,6 +269,8 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
                 LANGUAGES,
                 strings,
             ),
+            pending_out: Cell::new(false),
+            next_endpoint_index: Cell::new(0),
             endpoints: [
                 EndpointState::new(ENDPOINT_NUM),
                 #[cfg(feature = "vendor_hid")]
@@ -309,12 +313,14 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
     }
 
     pub fn receive_packet(&'a self, app: &mut App) {
-        for (_, s) in self.endpoints.iter().enumerate() {
-            if s.pending_out.get() {
-                // The previous packet has not yet been received, reject the new one.
-                continue;
-            } else {
-                s.pending_out.set(true);
+        if self.pending_out.get() {
+            // The previous packet has not yet been received, reject the new one.
+        } else {
+            self.pending_out.set(true);
+            // Process the next endpoint that has a delayed packet.
+            for i in self.next_endpoint_index.get()..self.next_endpoint_index.get() + NUM_ENDPOINTS
+            {
+                let s = &self.endpoints[i % NUM_ENDPOINTS];
                 // In case we reported Delay before, send the pending packet back to the client.
                 // Otherwise, there's nothing to do, the controller will send us a packet_out when a
                 // packet arrives.
@@ -347,7 +353,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
                 .client
                 .map_or(false, |client| client.can_receive_packet(&app))
             {
-                assert!(s.pending_out.take());
+                assert!(self.pending_out.take());
 
                 // Clear any pending packet on the transmitting side.
                 // It's up to the client to handle the received packet and decide if this packet
@@ -356,6 +362,13 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
 
                 self.client
                     .map(|client| client.packet_received(&buf, endpoint, app));
+                // Update next packet to send.
+                for (i, ep) in self.endpoints.iter().enumerate() {
+                    if ep.endpoint == endpoint {
+                        self.next_endpoint_index.set((i + 1) % NUM_ENDPOINTS);
+                        break;
+                    }
+                }
                 true
             } else {
                 // Cannot receive now, indicate a delay to the controller.
@@ -391,8 +404,8 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
     }
 
     fn cancel_out_transaction(&'a self, endpoint: usize) -> bool {
-        if let Some(s) = self.get_endpoint(endpoint) {
-            s.pending_out.take()
+        if let Some(_) = self.get_endpoint(endpoint) {
+            self.pending_out.take()
         } else {
             // Unsupported endpoint
             false
-- 
2.34.1


From 840f199659df6d4592e41ab31b8f9eb27bb3716d Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Tue, 8 Nov 2022 18:11:33 +0100
Subject: [PATCH 08/27] Add 13-send-packet-before-receiving.patch

---
 capsules/src/usb/usb_ctap.rs | 35 ++++++++++++++++++-----------------
 1 file changed, 18 insertions(+), 17 deletions(-)

diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index bf0b5bf4e..0956550c4 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -252,27 +252,28 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                             if app.waiting {
                                 CommandReturn::failure(ErrorCode::ALREADY)
                             } else {
+                                // send a packet before receiving one
+                                let r = kernel
+                                    .get_readonly_processbuffer(1)
+                                    .and_then(|process_buffer| {
+                                        process_buffer.enter(|buf| {
+                                            let mut packet: [u8; 64] = [0; 64];
+                                            buf.copy_to_slice(&mut packet);
+
+                                            // Indicates to the driver that we have a packet to send.
+                                            self.usb_client.transmit_packet(&packet, endpoint)
+                                        })
+                                    })
+                                    .unwrap_or(CommandReturn::failure(ErrorCode::FAIL));
+                                if !r.is_success() {
+                                    return r;
+                                }
+
                                 // Indicates to the driver that we can receive any pending packet.
                                 app.waiting = true;
                                 self.usb_client.receive_packet(app);
 
-                                if !app.waiting {
-                                    // The call to receive_packet() collected a pending packet.
-                                    CommandReturn::success()
-                                } else {
-                                    kernel
-                                        .get_readonly_processbuffer(1)
-                                        .and_then(|process_buffer| {
-                                            process_buffer.enter(|buf| {
-                                                let mut packet: [u8; 64] = [0; 64];
-                                                buf.copy_to_slice(&mut packet);
-
-                                                // Indicates to the driver that we have a packet to send.
-                                                self.usb_client.transmit_packet(&packet, endpoint)
-                                            })
-                                        })
-                                        .unwrap_or(CommandReturn::failure(ErrorCode::FAIL))
-                                }
+                                CommandReturn::success()
                             }
                         } else {
                             CommandReturn::failure(ErrorCode::INVAL)
-- 
2.34.1


From e9cd2aaef37dee9c73f7368dab52927e53a3d3bb Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Tue, 8 Nov 2022 20:08:53 +0100
Subject: [PATCH 09/27] Add 01-persistent-storage.patch

---
 chips/nrf52/src/nvmc.rs        | 229 ++++++++++++++++++++++++++++++++-
 kernel/src/kernel.rs           |  23 +++-
 kernel/src/process.rs          |  11 +-
 kernel/src/process_standard.rs |  58 ++++++++-
 4 files changed, 317 insertions(+), 4 deletions(-)

diff --git a/chips/nrf52/src/nvmc.rs b/chips/nrf52/src/nvmc.rs
index 61e94260e..a1194dc53 100644
--- a/chips/nrf52/src/nvmc.rs
+++ b/chips/nrf52/src/nvmc.rs
@@ -5,7 +5,14 @@
 use core::cell::Cell;
 use core::ops::{Index, IndexMut};
 use kernel::deferred_call::DeferredCall;
+use kernel::dynamic_deferred_call::{
+    DeferredCallHandle, DynamicDeferredCall, DynamicDeferredCallClient,
+};
+use kernel::grant::{AllowRoCount, AllowRwCount, Grant, UpcallCount};
 use kernel::hil;
+use kernel::process::ProcessId;
+use kernel::processbuffer::ReadableProcessBuffer;
+use kernel::syscall::CommandReturn;
 use kernel::utilities::cells::OptionalCell;
 use kernel::utilities::cells::TakeCell;
 use kernel::utilities::cells::VolatileCell;
@@ -142,7 +149,13 @@ register_bitfields! [u32,
 static DEFERRED_CALL: DeferredCall<DeferredCallTask> =
     unsafe { DeferredCall::new(DeferredCallTask::Nvmc) };
 
+type WORD = u32;
+const WORD_SIZE: usize = core::mem::size_of::<WORD>();
 const PAGE_SIZE: usize = 4096;
+const MAX_WORD_WRITES: usize = 2;
+const MAX_PAGE_ERASES: usize = 10000;
+const WORD_MASK: usize = WORD_SIZE - 1;
+const PAGE_MASK: usize = PAGE_SIZE - 1;
 
 /// This is a wrapper around a u8 array that is sized to a single page for the
 /// nrf. Users of this module must pass an object of this type to use the
@@ -218,6 +231,10 @@ impl Nvmc {
         }
     }
 
+    pub fn configure_readonly(&self) {
+        self.registers.config.write(Configuration::WEN::Ren);
+    }
+
     /// Configure the NVMC to allow writes to flash.
     pub fn configure_writeable(&self) {
         self.registers.config.write(Configuration::WEN::Wen);
@@ -233,6 +250,7 @@ impl Nvmc {
         self.registers
             .erasepage
             .write(ErasePage::ERASEPAGE.val(0x10001000));
+        self.registers.eraseuicr.write(EraseUicr::ERASEUICR::ERASE);
         while !self.is_ready() {}
     }
 
@@ -320,7 +338,7 @@ impl Nvmc {
         // Put the NVMC in write mode.
         self.registers.config.write(Configuration::WEN::Wen);
 
-        for i in (0..data.len()).step_by(4) {
+        for i in (0..data.len()).step_by(WORD_SIZE) {
             let word: u32 = (data[i + 0] as u32) << 0
                 | (data[i + 1] as u32) << 8
                 | (data[i + 2] as u32) << 16
@@ -388,3 +406,212 @@ impl hil::flash::Flash for Nvmc {
         self.erase_page(page_number)
     }
 }
+
+type NvmcDriverGrant = Grant<App, UpcallCount<1>, AllowRoCount<1>, AllowRwCount<0>>;
+
+/// Provides access to the writeable flash regions of the application.
+///
+/// The purpose of this driver is to provide low-level access to the embedded flash of nRF52 boards
+/// to allow applications to implement flash-aware (like wear-leveling) data-structures. The driver
+/// only permits applications to operate on their writeable flash regions. The API is blocking since
+/// the CPU is halted during write and erase operations.
+///
+/// Supported boards:
+/// - nRF52840 (tested)
+/// - nRF52833
+/// - nRF52811
+/// - nRF52810
+///
+/// The maximum number of writes for the nRF52832 board is not per word but per block (512 bytes)
+/// and as such doesn't exactly fit this API. However, it could be safely supported by returning
+/// either 1 for the maximum number of word writes (i.e. the flash can only be written once before
+/// being erased) or 8 for the word size (i.e. the write granularity is doubled). In both cases,
+/// only 128 writes per block are permitted while the flash supports 181.
+///
+/// # Syscalls
+///
+/// - SUBSCRIBE(0, done): The callback for COMMAND(2) and COMMAND(3).
+/// - COMMAND(0): Check the driver.
+/// - COMMAND(1, 0): Get the word size (always 4).
+/// - COMMAND(1, 1): Get the page size (always 4096).
+/// - COMMAND(1, 2): Get the maximum number of word writes between page erasures (always 2).
+/// - COMMAND(1, 3): Get the maximum number page erasures in the lifetime of the flash (always
+///     10000).
+/// - COMMAND(2, ptr, len): Write the allow slice to the flash region starting at `ptr`.
+///   - `ptr` must be word-aligned.
+///   - The allow slice length must be word aligned.
+///   - The region starting at `ptr` of the same length as the allow slice must be in a writeable
+///     flash region.
+/// - COMMAND(3, ptr, len): Erase a page.
+///   - `ptr` must be page-aligned.
+///   - The page starting at `ptr` must be in a writeable flash region.
+/// - ALLOW(0): The allow slice for COMMAND(2).
+pub struct SyscallDriver {
+    nvmc: &'static Nvmc,
+    apps: NvmcDriverGrant,
+    waiting: OptionalCell<ProcessId>,
+    deferred_caller: &'static DynamicDeferredCall,
+    deferred_handle: OptionalCell<DeferredCallHandle>,
+}
+
+pub const DRIVER_NUM: usize = 0x50003;
+
+#[derive(Default)]
+pub struct App {}
+
+fn is_write_needed(old: u32, new: u32) -> bool {
+    // No need to write if it would not modify the current value.
+    old & new != old
+}
+
+impl SyscallDriver {
+    pub fn new(
+        nvmc: &'static Nvmc,
+        apps: NvmcDriverGrant,
+        deferred_caller: &'static DynamicDeferredCall,
+    ) -> SyscallDriver {
+        nvmc.configure_readonly();
+        SyscallDriver {
+            nvmc,
+            apps,
+            waiting: OptionalCell::empty(),
+            deferred_caller,
+            deferred_handle: OptionalCell::empty(),
+        }
+    }
+
+    pub fn set_deferred_handle(&self, handle: DeferredCallHandle) {
+        self.deferred_handle.replace(handle);
+    }
+
+    /// Writes a word-aligned slice at a word-aligned address.
+    ///
+    /// Words are written only if necessary, i.e. if writing the new value would change the current
+    /// value. This can be used to simplify recovery operations (e.g. if power is lost during a
+    /// write operation). The application doesn't need to check which prefix has already been
+    /// written and may repeat the complete write that was interrupted.
+    ///
+    /// # Safety
+    ///
+    /// The words in this range must have been written less than `MAX_WORD_WRITES` since their last
+    /// page erasure.
+    ///
+    /// # Errors
+    ///
+    /// Fails with `EINVAL` if any of the following conditions does not hold:
+    /// - `ptr` must be word-aligned.
+    /// - `slice.len()` must be word-aligned.
+    /// - The slice starting at `ptr` of length `slice.len()` must fit in the storage.
+    fn write_slice(&self, ptr: usize, slice: &[u8]) -> CommandReturn {
+        if ptr & WORD_MASK != 0 || slice.len() & WORD_MASK != 0 {
+            return CommandReturn::failure(ErrorCode::INVAL);
+        }
+        self.nvmc.configure_writeable();
+        for (i, chunk) in slice.chunks(WORD_SIZE).enumerate() {
+            // `unwrap` cannot fail because `slice.len()` is word-aligned (see above).
+            let val = WORD::from_ne_bytes(<[u8; WORD_SIZE]>::try_from(chunk).unwrap());
+            let loc = unsafe { &*(ptr as *const VolatileCell<u32>).add(i) };
+            if is_write_needed(loc.get(), val) {
+                loc.set(val);
+            }
+        }
+        while !self.nvmc.is_ready() {}
+        self.nvmc.configure_readonly();
+        self.deferred_handle
+            .map(|handle| self.deferred_caller.set(*handle));
+        CommandReturn::success()
+    }
+
+    /// Erases a page at a page-aligned address.
+    ///
+    /// # Errors
+    ///
+    /// Fails with `EINVAL` if any of the following conditions does not hold:
+    /// - `ptr` must be page-aligned.
+    /// - The slice starting at `ptr` of length `PAGE_SIZE` must fit in the storage.
+    fn erase_page(&self, ptr: usize) -> CommandReturn {
+        if ptr & PAGE_MASK != 0 {
+            return CommandReturn::failure(ErrorCode::INVAL);
+        }
+        self.nvmc.erase_page_helper(ptr / PAGE_SIZE);
+        self.nvmc.configure_readonly();
+        self.deferred_handle
+            .map(|handle| self.deferred_caller.set(*handle));
+        CommandReturn::success()
+    }
+}
+
+impl DynamicDeferredCallClient for SyscallDriver {
+    fn call(&self, _handle: DeferredCallHandle) {
+        self.waiting.take().map(|process_id| {
+            self.apps.enter(process_id, |_, kernel_data| {
+                kernel_data.schedule_upcall(0, (0, 0, 0))
+            })
+        });
+    }
+}
+
+impl kernel::syscall::SyscallDriver for SyscallDriver {
+    fn allocate_grant(&self, process_id: ProcessId) -> Result<(), kernel::process::Error> {
+        self.apps.enter(process_id, |_, _| {})
+    }
+
+    fn command(
+        &self,
+        command_num: usize,
+        r2: usize,
+        r3: usize,
+        process_id: ProcessId,
+    ) -> CommandReturn {
+        match (command_num, r2, r3) {
+            (0, _, _) => CommandReturn::success(),
+
+            (1, 0, _) => CommandReturn::success_u32(WORD_SIZE.try_into().unwrap()),
+            (1, 1, _) => CommandReturn::success_u32(PAGE_SIZE.try_into().unwrap()),
+            (1, 2, _) => CommandReturn::success_u32(MAX_WORD_WRITES.try_into().unwrap()),
+            (1, 3, _) => CommandReturn::success_u32(MAX_PAGE_ERASES.try_into().unwrap()),
+            (1, _, _) => CommandReturn::failure(ErrorCode::INVAL),
+
+            (2, ptr, len) => self
+                .apps
+                .enter(process_id, |_, kernel| {
+                    let process_buffer = match kernel.get_readonly_processbuffer(1) {
+                        Ok(buf) => buf,
+                        Err(e) => return CommandReturn::failure(ErrorCode::from(e)),
+                    };
+
+                    let slice = match process_buffer.enter(|slice| {
+                        let mut buf: [u8; WORD_SIZE] = [0; WORD_SIZE];
+                        slice.copy_to_slice(&mut buf);
+                        buf
+                    }) {
+                        Ok(buf) => buf,
+                        Err(e) => return CommandReturn::failure(ErrorCode::from(e)),
+                    };
+
+                    if len != slice.len() {
+                        return CommandReturn::failure(ErrorCode::INVAL);
+                    }
+                    if self.waiting.is_some() {
+                        return CommandReturn::failure(ErrorCode::BUSY);
+                    }
+                    self.waiting.set(process_id);
+                    self.write_slice(ptr, slice.as_ref())
+                })
+                .unwrap_or_else(|err| err.into()),
+
+            (3, ptr, len) => {
+                if len != PAGE_SIZE {
+                    return CommandReturn::failure(ErrorCode::INVAL);
+                }
+                if self.waiting.is_some() {
+                    return CommandReturn::failure(ErrorCode::BUSY);
+                }
+                self.waiting.set(process_id);
+                self.erase_page(ptr)
+            }
+
+            _ => CommandReturn::failure(ErrorCode::NOSUPPORT),
+        }
+    }
+}
diff --git a/kernel/src/kernel.rs b/kernel/src/kernel.rs
index 0e3a2940a..9de227210 100644
--- a/kernel/src/kernel.rs
+++ b/kernel/src/kernel.rs
@@ -43,11 +43,20 @@ use tock_tbf::types::TbfParseError;
 /// is less than this threshold.
 pub(crate) const MIN_QUANTA_THRESHOLD_US: u32 = 500;
 
+/// Represents a storage location in flash.
+pub struct StorageLocation {
+    pub address: usize,
+    pub size: usize,
+}
+
 /// Main object for the kernel. Each board will need to create one.
 pub struct Kernel {
     /// This holds a pointer to the static array of Process pointers.
     processes: &'static [Option<&'static dyn process::Process>],
 
+    /// List of storage locations.
+    storage_locations: &'static [StorageLocation],
+
     /// A counter which keeps track of how many process identifiers have been
     /// created. This is used to create new unique identifiers for processes.
     process_identifier_max: Cell<usize>,
@@ -121,8 +130,16 @@ unsafe impl capabilities::ProcessApprovalCapability for KernelProcessApprovalCap
 
 impl Kernel {
     pub fn new(processes: &'static [Option<&'static dyn process::Process>]) -> Kernel {
+        Kernel::new_with_storage(processes, &[])
+    }
+
+    pub fn new_with_storage(
+        processes: &'static [Option<&'static dyn process::Process>],
+        storage_locations: &'static [StorageLocation],
+    ) -> Kernel {
         Kernel {
             processes,
+            storage_locations,
             process_identifier_max: Cell::new(0),
             grant_counter: Cell::new(0),
             grants_finalized: Cell::new(false),
@@ -131,12 +148,16 @@ impl Kernel {
                 process: Cell::new(0),
                 footer: Cell::new(0),
                 policy: OptionalCell::empty(),
-                processes: processes,
+                processes,
                 approve_cap: KernelProcessApprovalCapability {},
             },
         }
     }
 
+    pub fn storage_locations(&self) -> &'static [StorageLocation] {
+        self.storage_locations
+    }
+
     /// Helper function that moves all non-generic portions of process_map_or
     /// into a non-generic function to reduce code bloat from monomorphization.
     pub(crate) fn get_process(&self, processid: ProcessId) -> Option<&dyn process::Process> {
diff --git a/kernel/src/process.rs b/kernel/src/process.rs
index 01642a622..a3f924074 100644
--- a/kernel/src/process.rs
+++ b/kernel/src/process.rs
@@ -8,7 +8,7 @@ use core::str;
 use crate::capabilities;
 use crate::errorcode::ErrorCode;
 use crate::ipc;
-use crate::kernel::Kernel;
+use crate::kernel::{Kernel, StorageLocation};
 use crate::platform::mpu::{self};
 use crate::processbuffer::{ReadOnlyProcessBuffer, ReadWriteProcessBuffer};
 use crate::storage_permissions;
@@ -419,6 +419,15 @@ pub trait Process {
     /// writeable flash region.
     fn get_writeable_flash_region(&self, region_index: usize) -> (u32, u32);
 
+    /// How many storage locations are defined for this process.
+    fn number_storage_locations(&self) -> usize;
+
+    /// Get the i-th storage location.
+    fn get_storage_location(&self, index: usize) -> Option<&StorageLocation>;
+
+    /// Whether a slice fits in a storage location.
+    fn fits_in_storage_location(&self, ptr: usize, len: usize) -> bool;
+
     /// Debug function to update the kernel on where the stack starts for this
     /// process. Processes are not required to call this through the memop
     /// system call, but it aids in debugging the process.
diff --git a/kernel/src/process_standard.rs b/kernel/src/process_standard.rs
index 16fefe8e1..f14a57952 100644
--- a/kernel/src/process_standard.rs
+++ b/kernel/src/process_standard.rs
@@ -15,7 +15,7 @@ use crate::collections::ring_buffer::RingBuffer;
 use crate::config;
 use crate::debug;
 use crate::errorcode::ErrorCode;
-use crate::kernel::Kernel;
+use crate::kernel::{Kernel, StorageLocation};
 use crate::platform::chip::Chip;
 use crate::platform::mpu::{self, MPU};
 use crate::process::{Error, FunctionCall, FunctionCallSource, Process, State, Task};
@@ -519,6 +519,35 @@ impl<C: Chip> Process for ProcessStandard<'_, C> {
         self.header.get_writeable_flash_region(region_index)
     }
 
+    fn number_storage_locations(&self) -> usize {
+        self.kernel.storage_locations().len()
+    }
+
+    fn get_storage_location(&self, index: usize) -> Option<&StorageLocation> {
+        self.kernel.storage_locations().get(index)
+    }
+
+    fn fits_in_storage_location(&self, ptr: usize, len: usize) -> bool {
+        self.kernel
+            .storage_locations()
+            .iter()
+            .any(|storage_location| {
+                let storage_ptr = storage_location.address;
+                let storage_len = storage_location.size;
+                // We want to check the 2 following inequalities:
+                // (1) `storage_ptr <= ptr`
+                // (2) `ptr + len <= storage_ptr + storage_len`
+                // However, the second one may overflow written as is. We introduce a third
+                // inequality to solve this issue:
+                // (3) `len <= storage_len`
+                // Using this third inequality, we can rewrite the second one as:
+                // (4) `ptr - storage_ptr <= storage_len - len`
+                // This fourth inequality is equivalent to the second one but doesn't overflow when
+                // the first and third inequalities hold.
+                storage_ptr <= ptr && len <= storage_len && ptr - storage_ptr <= storage_len - len
+            })
+    }
+
     fn update_stack_start_pointer(&self, stack_pointer: *const u8) {
         if stack_pointer >= self.mem_start() && stack_pointer < self.mem_end() {
             self.debug.map(|debug| {
@@ -1468,6 +1497,33 @@ impl<C: 'static + Chip> ProcessStandard<'_, C> {
             return Err((ProcessLoadError::MpuInvalidFlashLength, remaining_memory));
         }
 
+        // Allocate MPU region for the storage locations. The storage locations are currently
+        // readable by all processes due to lack of stable app id.
+        for storage_location in kernel.storage_locations() {
+            if chip
+                .mpu()
+                .allocate_region(
+                    storage_location.address as *const u8,
+                    storage_location.size,
+                    storage_location.size,
+                    mpu::Permissions::ReadOnly,
+                    &mut mpu_config,
+                )
+                .is_some()
+            {
+                continue;
+            }
+            if config::CONFIG.debug_load_processes {
+                debug!(
+                    "[!] flash=[{:#010X}:{:#010X}] process={:?} - couldn't allocate flash region",
+                    storage_location.address,
+                    storage_location.address + storage_location.size,
+                    process_name
+                );
+            }
+            return Ok((None, remaining_memory));
+        }
+
         // Determine how much space we need in the application's memory space
         // just for kernel and grant state. We need to make sure we allocate
         // enough memory just for that.
-- 
2.34.1


From 63a283e565aca00984d6b1e261a2f5a6b9226284 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Tue, 8 Nov 2022 20:19:37 +0100
Subject: [PATCH 10/27] Add 04-update-uicr.patch

---
 boards/nordic/nrf52_components/src/startup.rs |  8 ++
 chips/nrf52/src/uicr.rs                       | 87 +++++++++++++------
 2 files changed, 68 insertions(+), 27 deletions(-)

diff --git a/boards/nordic/nrf52_components/src/startup.rs b/boards/nordic/nrf52_components/src/startup.rs
index 09dc5292c..c1bd961cc 100644
--- a/boards/nordic/nrf52_components/src/startup.rs
+++ b/boards/nordic/nrf52_components/src/startup.rs
@@ -55,6 +55,9 @@ impl<'a> Component for NrfStartupComponent<'a> {
             erase_uicr |= !uicr.is_nfc_pins_protection_enabled();
         }
 
+        // Avoid killing the DFU bootloader if present
+        let (dfu_start_addr, dfu_settings_addr) = uicr.get_dfu_params();
+
         if erase_uicr {
             self.nvmc.erase_uicr();
         }
@@ -64,6 +67,11 @@ impl<'a> Component for NrfStartupComponent<'a> {
 
         let mut needs_soft_reset: bool = false;
 
+        // Restore DFU bootloader settings if we erased
+        if erase_uicr {
+            uicr.set_dfu_params(dfu_start_addr, dfu_settings_addr);
+        }
+
         // Configure reset pins
         if uicr
             .get_psel0_reset_pin()
diff --git a/chips/nrf52/src/uicr.rs b/chips/nrf52/src/uicr.rs
index 3b51717d0..3086394aa 100644
--- a/chips/nrf52/src/uicr.rs
+++ b/chips/nrf52/src/uicr.rs
@@ -1,39 +1,43 @@
 //! User information configuration registers
-//!
-//! Minimal implementation to support activation of the reset button on
-//! nRF52-DK.
 
 use enum_primitive::cast::FromPrimitive;
 use kernel::utilities::registers::interfaces::{ReadWriteable, Readable, Writeable};
-use kernel::utilities::registers::{register_bitfields, ReadWrite};
+use kernel::utilities::registers::{register_bitfields, register_structs, ReadWrite};
 use kernel::utilities::StaticRef;
 
 use crate::gpio::Pin;
 
 const UICR_BASE: StaticRef<UicrRegisters> =
-    unsafe { StaticRef::new(0x10001200 as *const UicrRegisters) };
-
-#[repr(C)]
-struct UicrRegisters {
-    /// Mapping of the nRESET function (see POWER chapter for details)
-    /// - Address: 0x200 - 0x204
-    pselreset0: ReadWrite<u32, Pselreset::Register>,
-    /// Mapping of the nRESET function (see POWER chapter for details)
-    /// - Address: 0x204 - 0x208
-    pselreset1: ReadWrite<u32, Pselreset::Register>,
-    /// Access Port protection
-    /// - Address: 0x208 - 0x20c
-    approtect: ReadWrite<u32, ApProtect::Register>,
-    /// Setting of pins dedicated to NFC functionality: NFC antenna or GPIO
-    /// - Address: 0x20c - 0x210
-    nfcpins: ReadWrite<u32, NfcPins::Register>,
-    _reserved1: [u32; 60],
-    /// External circuitry to be supplied from VDD pin.
-    /// - Address: 0x300 - 0x304
-    extsupply: ReadWrite<u32, ExtSupply::Register>,
-    /// GPIO reference voltage
-    /// - Address: 0x304 - 0x308
-    regout0: ReadWrite<u32, RegOut::Register>,
+    unsafe { StaticRef::new(0x10001000 as *const UicrRegisters) };
+
+register_structs! {
+   UicrRegisters {
+       (0x000 => _reserved1),
+       /// Reserved for Nordic firmware design
+       (0x014 => nrffw: [ReadWrite<u32>; 13]),
+       (0x048 => _reserved2),
+       /// Reserved for Nordic hardware design
+       (0x050 => nrfhw: [ReadWrite<u32>; 12]),
+       /// Reserved for customer
+       (0x080 => customer: [ReadWrite<u32>; 32]),
+       (0x100 => _reserved3),
+       /// Mapping of the nRESET function (see POWER chapter for details)
+       (0x200 => pselreset0: ReadWrite<u32, Pselreset::Register>),
+       /// Mapping of the nRESET function (see POWER chapter for details)
+       (0x204 => pselreset1: ReadWrite<u32, Pselreset::Register>),
+       /// Access Port protection
+       (0x208 => approtect: ReadWrite<u32, ApProtect::Register>),
+       /// Setting of pins dedicated to NFC functionality: NFC antenna or GPIO
+       /// - Address: 0x20c - 0x210
+       (0x20c => nfcpins: ReadWrite<u32, NfcPins::Register>),
+       (0x210 => debugctrl: ReadWrite<u32, DebugControl::Register>),
+       (0x214 => _reserved4),
+       /// External circuitry to be supplied from VDD pin.
+       (0x300 => extsupply: ReadWrite<u32, ExtSupply::Register>),
+       /// GPIO reference voltage
+       (0x304 => regout0: ReadWrite<u32, RegOut::Register>),
+       (0x308 => @END),
+   }
 }
 
 register_bitfields! [u32,
@@ -59,6 +63,23 @@ register_bitfields! [u32,
             DISABLED = 0xff
         ]
     ],
+
+    /// Processor debug control
+    DebugControl [
+        CPUNIDEN OFFSET(0) NUMBITS(8) [
+            /// Enable
+            ENABLED = 0xff,
+            /// Disable
+            DISABLED = 0x00
+        ],
+        CPUFPBEN OFFSET(8) NUMBITS(8) [
+            /// Enable
+            ENABLED = 0xff,
+            /// Disable
+            DISABLED = 0x00
+        ]
+    ],
+
     /// Setting of pins dedicated to NFC functionality: NFC antenna or GPIO
     NfcPins [
         /// Setting pins dedicated to NFC functionality
@@ -169,6 +190,18 @@ impl Uicr {
         }
     }
 
+    pub fn get_dfu_params(&self) -> (u32, u32) {
+        (
+            self.registers.nrffw[0].get(), // DFU start address
+            self.registers.nrffw[1].get(), // DFU settings address
+        )
+    }
+
+    pub fn set_dfu_params(&self, dfu_start_addr: u32, dfu_settings_addr: u32) {
+        self.registers.nrffw[0].set(dfu_start_addr);
+        self.registers.nrffw[1].set(dfu_settings_addr);
+    }
+
     pub fn is_nfc_pins_protection_enabled(&self) -> bool {
         self.registers.nfcpins.matches_all(NfcPins::PROTECT::NFC)
     }
-- 
2.34.1


From db94714dc8f6880933ab585618536bd5b53f6b65 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Tue, 8 Nov 2022 22:58:06 +0100
Subject: [PATCH 11/27] Add 06-upgrade-partitions.patch

---
 kernel/src/kernel.rs | 19 +++++++++++++++++++
 kernel/src/memop.rs  |  9 +++++++++
 2 files changed, 28 insertions(+)

diff --git a/kernel/src/kernel.rs b/kernel/src/kernel.rs
index 9de227210..f4fd0a083 100644
--- a/kernel/src/kernel.rs
+++ b/kernel/src/kernel.rs
@@ -43,10 +43,18 @@ use tock_tbf::types::TbfParseError;
 /// is less than this threshold.
 pub(crate) const MIN_QUANTA_THRESHOLD_US: u32 = 500;
 
+/// Represents the type of a storage slice.
+#[derive(Copy, Clone)]
+pub enum StorageType {
+    Store = 1,
+    Partition = 2,
+}
+
 /// Represents a storage location in flash.
 pub struct StorageLocation {
     pub address: usize,
     pub size: usize,
+    pub storage_type: StorageType,
 }
 
 /// Main object for the kernel. Each board will need to create one.
@@ -1417,6 +1425,17 @@ enum FooterCheckResult {
     Error,              // An internal error occurred, no check started
 }
 
+impl TryFrom<StorageType> for u32 {
+    type Error = ();
+
+    fn try_from(value: StorageType) -> Result<Self, Self::Error> {
+        match value {
+            StorageType::Store => Ok(StorageType::Store as u32),
+            StorageType::Partition => Ok(StorageType::Partition as u32),
+        }
+    }
+}
+
 impl ProcessCheckerMachine {
     /// Check the next footer of the next process. Returns:
     ///   - Ok(true) if a valid footer was found and is being checked
diff --git a/kernel/src/memop.rs b/kernel/src/memop.rs
index 51d89f37c..4d47f77d2 100644
--- a/kernel/src/memop.rs
+++ b/kernel/src/memop.rs
@@ -107,6 +107,15 @@ pub(crate) fn memop(process: &dyn Process, op_type: usize, r1: usize) -> Syscall
             SyscallReturn::Success
         }
 
+        // Op Type 15: The type of the storage location indexed by r1.
+        15 => {
+            match process.get_storage_location(r1) {
+                None => SyscallReturn::Failure(ErrorCode::FAIL),
+                //Some(x) => ReturnCode::SuccessWithValue { value: x.storage_type as usize }
+                Some(x) => SyscallReturn::SuccessU32(x.storage_type.try_into().unwrap())
+            }
+        }
+
         _ => SyscallReturn::Failure(ErrorCode::NOSUPPORT),
     }
 }
-- 
2.34.1


From b7df5474b71acf3d82d59da80b7f369d88635988 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Wed, 9 Nov 2022 22:00:00 +0100
Subject: [PATCH 12/27] Add OpenSK's patched nrf52840_dongle board definitions

---
 Cargo.toml                                    |   2 +
 boards/nordic/nrf52840_dongle_dfu/Cargo.toml  |  21 +
 boards/nordic/nrf52840_dongle_dfu/Makefile    |  29 +
 boards/nordic/nrf52840_dongle_dfu/build.rs    |   4 +
 boards/nordic/nrf52840_dongle_dfu/layout.ld   |  10 +
 .../nordic/nrf52840_dongle_opensk/Cargo.toml  |  17 +
 boards/nordic/nrf52840_dongle_opensk/Makefile |  28 +
 .../nordic/nrf52840_dongle_opensk/README.md   |  41 ++
 boards/nordic/nrf52840_dongle_opensk/build.rs |   4 +
 .../jtag/gdbinit_pca10040.jlink               |  25 +
 .../jtag/jdbserver_pca10040.sh                |   1 +
 .../nordic/nrf52840_dongle_opensk/layout.ld   |   2 +
 .../nordic/nrf52840_dongle_opensk/src/io.rs   |  70 +++
 .../nordic/nrf52840_dongle_opensk/src/main.rs | 514 ++++++++++++++++++
 kernel/src/lib.rs                             |   1 +
 15 files changed, 769 insertions(+)
 create mode 100644 boards/nordic/nrf52840_dongle_dfu/Cargo.toml
 create mode 100644 boards/nordic/nrf52840_dongle_dfu/Makefile
 create mode 100644 boards/nordic/nrf52840_dongle_dfu/build.rs
 create mode 100644 boards/nordic/nrf52840_dongle_dfu/layout.ld
 create mode 100644 boards/nordic/nrf52840_dongle_opensk/Cargo.toml
 create mode 100644 boards/nordic/nrf52840_dongle_opensk/Makefile
 create mode 100644 boards/nordic/nrf52840_dongle_opensk/README.md
 create mode 100644 boards/nordic/nrf52840_dongle_opensk/build.rs
 create mode 100644 boards/nordic/nrf52840_dongle_opensk/jtag/gdbinit_pca10040.jlink
 create mode 100755 boards/nordic/nrf52840_dongle_opensk/jtag/jdbserver_pca10040.sh
 create mode 100644 boards/nordic/nrf52840_dongle_opensk/layout.ld
 create mode 100644 boards/nordic/nrf52840_dongle_opensk/src/io.rs
 create mode 100644 boards/nordic/nrf52840_dongle_opensk/src/main.rs

diff --git a/Cargo.toml b/Cargo.toml
index cc5caca84..503769e2c 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -25,6 +25,8 @@ members = [
     "boards/microbit_v2",
     "boards/nordic/nrf52840dk",
     "boards/nordic/nrf52840_dongle",
+    "boards/nordic/nrf52840_dongle_opensk",
+    "boards/nordic/nrf52840_dongle_dfu",
     "boards/nordic/nrf52dk",
     "boards/sma_q3",
     "boards/nucleo_f429zi",
diff --git a/boards/nordic/nrf52840_dongle_dfu/Cargo.toml b/boards/nordic/nrf52840_dongle_dfu/Cargo.toml
new file mode 100644
index 000000000..aa32eeff3
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_dfu/Cargo.toml
@@ -0,0 +1,21 @@
+[package]
+name = "nrf52840_dongle_dfu"
+version = "0.1.0"
+authors = ["Tock Project Developers <tock-dev@googlegroups.com>"]
+build = "build.rs"
+edition = "2018"
+
+[[bin]]
+path = "../nrf52840_dongle_opensk/src/main.rs"
+name = "nrf52840_dongle_dfu"
+
+[dependencies]
+components = { path = "../../components" }
+cortexm4 = { path = "../../../arch/cortex-m4" }
+capsules = { path = "../../../capsules" }
+kernel = { path = "../../../kernel" }
+nrf52840 = { path = "../../../chips/nrf52840" }
+nrf52_components = { path = "../nrf52_components" }
+
+[features]
+vendor_hid = ["capsules/vendor_hid"]
diff --git a/boards/nordic/nrf52840_dongle_dfu/Makefile b/boards/nordic/nrf52840_dongle_dfu/Makefile
new file mode 100644
index 000000000..58771b3a6
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_dfu/Makefile
@@ -0,0 +1,29 @@
+# Makefile for building the tock kernel for the nRF development kit
+
+TOCK_ARCH=cortex-m4
+TARGET=thumbv7em-none-eabi
+PLATFORM=nrf52840_dongle_dfu
+
+include ../../Makefile.common
+
+TOCKLOADER=tockloader
+
+# Where in the nrf52 flash to load the kernel with `tockloader`
+KERNEL_ADDRESS=0x01000
+
+# Upload programs over uart with tockloader
+ifdef PORT
+  TOCKLOADER_GENERAL_FLAGS += --port $(PORT)
+endif
+
+TOCKLOADER_JTAG_FLAGS = --jlink --arch $(TOCK_ARCH) --board $(PLATFORM) --page-size 4096 --jlink-device nrf52840_xxaa
+
+# Upload the kernel over JTAG
+.PHONY: flash
+flash: $(TOCK_ROOT_DIRECTORY)target/$(TARGET)/release/$(PLATFORM).bin
+	$(TOCKLOADER) $(TOCKLOADER_GENERAL_FLAGS) flash --address $(KERNEL_ADDRESS) $(TOCKLOADER_JTAG_FLAGS) $<
+
+# Upload the kernel over serial/bootloader
+.PHONY: program
+program: $(TOCK_ROOT_DIRECTORY)target/$(TARGET)/release/$(PLATFORM).hex
+	$(error Cannot program nRF52 Dongle over USB. Use \`make flash\` and JTAG)
diff --git a/boards/nordic/nrf52840_dongle_dfu/build.rs b/boards/nordic/nrf52840_dongle_dfu/build.rs
new file mode 100644
index 000000000..1fdd4924f
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_dfu/build.rs
@@ -0,0 +1,4 @@
+fn main() {
+    println!("cargo:rerun-if-changed=layout.ld");
+    println!("cargo:rerun-if-changed=../../kernel_layout.ld");
+}
diff --git a/boards/nordic/nrf52840_dongle_dfu/layout.ld b/boards/nordic/nrf52840_dongle_dfu/layout.ld
new file mode 100644
index 000000000..41ae608ac
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_dfu/layout.ld
@@ -0,0 +1,10 @@
+MEMORY
+{
+  rom (rx)  : ORIGIN = 0x00001000, LENGTH = 188K
+  prog (rx) : ORIGIN = 0x00030000, LENGTH = 832K
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 256K
+}
+
+MPU_MIN_ALIGN = 8K;
+
+INCLUDE ../../kernel_layout.ld
diff --git a/boards/nordic/nrf52840_dongle_opensk/Cargo.toml b/boards/nordic/nrf52840_dongle_opensk/Cargo.toml
new file mode 100644
index 000000000..105d64f3c
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_opensk/Cargo.toml
@@ -0,0 +1,17 @@
+[package]
+name = "nrf52840_dongle_opensk"
+version = "0.1.0"
+authors = ["Tock Project Developers <tock-dev@googlegroups.com>"]
+build = "build.rs"
+edition = "2018"
+
+[dependencies]
+components = { path = "../../components" }
+cortexm4 = { path = "../../../arch/cortex-m4" }
+capsules = { path = "../../../capsules" }
+kernel = { path = "../../../kernel" }
+nrf52840 = { path = "../../../chips/nrf52840" }
+nrf52_components = { path = "../nrf52_components" }
+
+[features]
+vendor_hid = ["capsules/vendor_hid"]
diff --git a/boards/nordic/nrf52840_dongle_opensk/Makefile b/boards/nordic/nrf52840_dongle_opensk/Makefile
new file mode 100644
index 000000000..db4912a01
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_opensk/Makefile
@@ -0,0 +1,28 @@
+# Makefile for building the tock kernel for the nRF development kit
+
+TARGET=thumbv7em-none-eabi
+PLATFORM=nrf52840_dongle_opensk
+
+include ../../Makefile.common
+
+TOCKLOADER=tockloader
+
+# Where in the nrf52 flash to load the kernel with `tockloader`
+KERNEL_ADDRESS=0x00000
+
+# Upload programs over uart with tockloader
+ifdef PORT
+  TOCKLOADER_GENERAL_FLAGS += --port $(PORT)
+endif
+
+TOCKLOADER_JTAG_FLAGS = --jlink --board nrf52dk
+
+# Upload the kernel over JTAG
+.PHONY: flash
+flash: $(TOCK_ROOT_DIRECTORY)target/$(TARGET)/release/$(PLATFORM).bin
+	$(TOCKLOADER) $(TOCKLOADER_GENERAL_FLAGS) flash --address $(KERNEL_ADDRESS) $(TOCKLOADER_JTAG_FLAGS) $<
+
+# Upload the kernel over serial/bootloader
+.PHONY: program
+program: $(TOCK_ROOT_DIRECTORY)target/$(TARGET)/release/$(PLATFORM).hex
+	$(error Cannot program nRF52840-Dongle over USB. Use \`make flash\` and JTAG)
diff --git a/boards/nordic/nrf52840_dongle_opensk/README.md b/boards/nordic/nrf52840_dongle_opensk/README.md
new file mode 100644
index 000000000..bd0d55729
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_opensk/README.md
@@ -0,0 +1,41 @@
+Platform-Specific Instructions: nRF52840-Dongle
+===================================
+
+This is an adapted nrf52840\_dongle made to work with OpenSK.
+
+The [nRF52840 Dongle](https://www.nordicsemi.com/Software-and-Tools/Development-Kits/nRF52840-Dongle)
+is a platform based around the nRF52840, an SoC with an ARM Cortex-M4 and a BLE radio.
+The kit is uses a USB key form factor and includes 1 button, 1 red LED and 1 RGB LED.
+
+## Getting Started
+
+To program the nRF52840 Dongle with Tock, you will need a JLink JTAG device and the
+appropriate cables. An example setup is:
+
+- [JLink JTAG Device](https://www.digikey.com/product-detail/en/segger-microcontroller-systems/8.08.90-J-LINK-EDU/899-1008-ND/2263130)
+- [ARM to TagConnect Adapter](https://www.digikey.com/product-detail/en/tag-connect-llc/TC2050-ARM2010/TC2050-ARM2010-ND/3528170)
+- [10pin TagConnect Cable](https://www.digikey.com/product-detail/en/tag-connect-llc/TC2050-IDC-NL/TC2050-IDC-NL-ND/2605367)
+
+Then, follow the [Tock Getting Started guide](../../../doc/Getting_Started.md)
+
+JTAG is the preferred method to program. The development kit has the JTAG pins exposed either
+through the half-moons pads or, below the PCB, on a Tag-Connect TC2050 connector footprint.
+You need to [install JTAG software](../../../doc/Getting_Started.md#optional-requirements).
+
+## Programming the kernel
+Once you have all software installed, you should be able to simply run
+make flash in this directory to install a fresh kernel.
+
+## Programming user-level applications
+You can program an application via JTAG using `tockloader`:
+
+```shell
+$ cd libtock-c/examples/<app>
+$ make
+$ tockloader install --jlink --board nrf52dk
+```
+
+## Debugging
+
+See the [nrf52dk README](../nrf52dk/README.md) for information about debugging
+the nRF52840 Dongle.
diff --git a/boards/nordic/nrf52840_dongle_opensk/build.rs b/boards/nordic/nrf52840_dongle_opensk/build.rs
new file mode 100644
index 000000000..1fdd4924f
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_opensk/build.rs
@@ -0,0 +1,4 @@
+fn main() {
+    println!("cargo:rerun-if-changed=layout.ld");
+    println!("cargo:rerun-if-changed=../../kernel_layout.ld");
+}
diff --git a/boards/nordic/nrf52840_dongle_opensk/jtag/gdbinit_pca10040.jlink b/boards/nordic/nrf52840_dongle_opensk/jtag/gdbinit_pca10040.jlink
new file mode 100644
index 000000000..23a8c5b62
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_opensk/jtag/gdbinit_pca10040.jlink
@@ -0,0 +1,25 @@
+#
+#
+#
+# J-LINK GDB SERVER initialization
+#
+# This connects to a GDB Server listening
+# for commands on localhost at tcp port 2331
+target remote localhost:2331
+monitor speed 30
+file ../../../../target/thumbv7em-none-eabi/release/nrf52840_dongle
+monitor reset
+#
+# CPU core initialization (to be done by user)
+#
+# Set the processor mode
+# monitor reg cpsr = 0xd3
+# Set auto JTAG speed
+monitor speed auto
+# Setup GDB FOR FASTER DOWNLOADS
+set remote memory-write-packet-size 1024
+set remote memory-write-packet-size fixed
+# tui enable
+# layout split
+# layout service_pending_interrupts
+b reset_handler
diff --git a/boards/nordic/nrf52840_dongle_opensk/jtag/jdbserver_pca10040.sh b/boards/nordic/nrf52840_dongle_opensk/jtag/jdbserver_pca10040.sh
new file mode 100755
index 000000000..1c9cd9b24
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_opensk/jtag/jdbserver_pca10040.sh
@@ -0,0 +1 @@
+JLinkGDBServer -device nRF52840_xxAA -speed 1200 -if swd -AutoConnect 1 -port 2331
diff --git a/boards/nordic/nrf52840_dongle_opensk/layout.ld b/boards/nordic/nrf52840_dongle_opensk/layout.ld
new file mode 100644
index 000000000..a8da37599
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_opensk/layout.ld
@@ -0,0 +1,2 @@
+INCLUDE ../nrf52840_chip_layout.ld
+INCLUDE ../../kernel_layout.ld
diff --git a/boards/nordic/nrf52840_dongle_opensk/src/io.rs b/boards/nordic/nrf52840_dongle_opensk/src/io.rs
new file mode 100644
index 000000000..8c60a865d
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_opensk/src/io.rs
@@ -0,0 +1,70 @@
+use core::fmt::Write;
+use core::panic::PanicInfo;
+use cortexm4;
+use kernel::debug;
+use kernel::debug::IoWrite;
+use kernel::hil::led;
+use kernel::hil::uart::{self, Configure};
+use nrf52840::gpio::Pin;
+
+use crate::CHIP;
+use crate::PROCESSES;
+use crate::PROCESS_PRINTER;
+
+struct Writer {
+    initialized: bool,
+}
+
+static mut WRITER: Writer = Writer { initialized: false };
+
+impl Write for Writer {
+    fn write_str(&mut self, s: &str) -> ::core::fmt::Result {
+        self.write(s.as_bytes());
+        Ok(())
+    }
+}
+
+impl IoWrite for Writer {
+    fn write(&mut self, buf: &[u8]) {
+        // Here, we create a second instance of the Uarte struct.
+        // This is okay because we only call this during a panic, and
+        // we will never actually process the interrupts
+        let uart = nrf52840::uart::Uarte::new();
+        if !self.initialized {
+            self.initialized = true;
+            let _ = uart.configure(uart::Parameters {
+                baud_rate: 115200,
+                stop_bits: uart::StopBits::One,
+                parity: uart::Parity::None,
+                hw_flow_control: false,
+                width: uart::Width::Eight,
+            });
+        }
+        for &c in buf {
+            unsafe {
+                uart.send_byte(c);
+            }
+            while !uart.tx_ready() {}
+        }
+    }
+}
+
+#[cfg(not(test))]
+#[no_mangle]
+#[panic_handler]
+/// Panic handler
+pub unsafe extern "C" fn panic_fmt(pi: &PanicInfo) -> ! {
+    // The nRF52840 Dongle LEDs (see back of board)
+    let led_kernel_pin = &nrf52840::gpio::GPIOPin::new(Pin::P0_06);
+    let led = &mut led::LedLow::new(led_kernel_pin);
+    let writer = &mut WRITER;
+    debug::panic(
+        &mut [led],
+        writer,
+        pi,
+        &cortexm4::support::nop,
+        &PROCESSES,
+        &CHIP,
+        &PROCESS_PRINTER,
+    )
+}
diff --git a/boards/nordic/nrf52840_dongle_opensk/src/main.rs b/boards/nordic/nrf52840_dongle_opensk/src/main.rs
new file mode 100644
index 000000000..7f5df6db3
--- /dev/null
+++ b/boards/nordic/nrf52840_dongle_opensk/src/main.rs
@@ -0,0 +1,514 @@
+//! Tock kernel for the Nordic Semiconductor nRF52840 dongle.
+//!
+//! It is based on nRF52840 SoC (Cortex M4 core with a BLE transceiver) with
+//! many exported I/O and peripherals.
+
+#![no_std]
+// Disable this attribute when documenting, as a workaround for
+// https://github.com/rust-lang/rust/issues/62184.
+#![cfg_attr(not(doc), no_main)]
+#![deny(missing_docs)]
+
+use capsules::virtual_alarm::VirtualMuxAlarm;
+use kernel::component::Component;
+use kernel::dynamic_deferred_call::{DynamicDeferredCall, DynamicDeferredCallClientState};
+use kernel::hil::led::LedLow;
+use kernel::hil::time::Counter;
+use kernel::platform::{KernelResources, SyscallDriverLookup, SyscallFilter};
+use kernel::scheduler::round_robin::RoundRobinSched;
+use kernel::StorageLocation;
+use kernel::StorageType;
+#[allow(unused_imports)]
+use kernel::{capabilities, create_capability, debug, debug_gpio, debug_verbose, static_init};
+use nrf52840::gpio::Pin;
+use nrf52840::interrupt_service::Nrf52840DefaultPeripherals;
+use nrf52_components::{self, UartChannel, UartPins};
+
+// The nRF52840 Dongle LEDs
+const LED1_PIN: Pin = Pin::P0_06;
+const LED2_R_PIN: Pin = Pin::P0_08;
+const LED2_G_PIN: Pin = Pin::P1_09;
+const LED2_B_PIN: Pin = Pin::P0_12;
+
+// The nRF52840 Dongle button
+const BUTTON_PIN: Pin = Pin::P1_06;
+const BUTTON_RST_PIN: Pin = Pin::P0_18;
+
+const UART_RTS: Option<Pin> = Some(Pin::P0_13);
+const UART_TXD: Pin = Pin::P0_15;
+const UART_CTS: Option<Pin> = Some(Pin::P0_17);
+const UART_RXD: Pin = Pin::P0_20;
+
+// SPI pins not currently in use, but left here for convenience
+const _SPI_MOSI: Pin = Pin::P1_01;
+const _SPI_MISO: Pin = Pin::P1_02;
+const _SPI_CLK: Pin = Pin::P1_04;
+
+/// UART Writer
+pub mod io;
+
+const VENDOR_ID: u16 = 0x1915; // Nordic Semiconductor
+const PRODUCT_ID: u16 = 0x521f; // nRF52840 Dongle (PCA10059)
+static STRINGS: &'static [&'static str] = &[
+    // Manufacturer
+    "Nordic Semiconductor ASA",
+    // Product
+    "OpenSK",
+    // Serial number
+    "v1.0",
+];
+
+// State for loading and holding applications.
+// How should the kernel respond when a process faults.
+const FAULT_RESPONSE: kernel::process::PanicFaultPolicy = kernel::process::PanicFaultPolicy {};
+
+// Number of concurrent processes this platform supports.
+const NUM_PROCS: usize = 8;
+
+static mut PROCESSES: [Option<&'static dyn kernel::process::Process>; NUM_PROCS] =
+    [None; NUM_PROCS];
+
+static mut STORAGE_LOCATIONS: [StorageLocation; 2] = [
+    // We implement NUM_PAGES = 20 as 16 + 4 to satisfy the MPU.
+    StorageLocation {
+        address: 0xC0000,
+        size: 0x10000, // 16 pages
+        storage_type: StorageType::Store,
+    },
+    StorageLocation {
+        address: 0xD0000,
+        size: 0x4000, // 4 pages
+        storage_type: StorageType::Store,
+    },
+];
+
+// Static reference to chip for panic dumps
+static mut CHIP: Option<&'static nrf52840::chip::NRF52<Nrf52840DefaultPeripherals>> = None;
+// Static reference to process printer for panic dumps
+static mut PROCESS_PRINTER: Option<&'static kernel::process::ProcessPrinterText> = None;
+
+/// Dummy buffer that causes the linker to reserve enough space for the stack.
+#[no_mangle]
+#[link_section = ".stack_buffer"]
+pub static mut STACK_MEMORY: [u8; 0x1000] = [0; 0x1000];
+
+/// Supported drivers by the platform
+pub struct Platform {
+    button: &'static capsules::button::Button<'static, nrf52840::gpio::GPIOPin<'static>>,
+    pconsole: &'static capsules::process_console::ProcessConsole<
+        'static,
+        VirtualMuxAlarm<'static, nrf52840::rtc::Rtc<'static>>,
+        components::process_console::Capability,
+    >,
+    console: &'static capsules::console::Console<'static>,
+    gpio: &'static capsules::gpio::GPIO<'static, nrf52840::gpio::GPIOPin<'static>>,
+    led: &'static capsules::led::LedDriver<
+        'static,
+        LedLow<'static, nrf52840::gpio::GPIOPin<'static>>,
+        4,
+    >,
+    rng: &'static capsules::rng::RngDriver<'static>,
+    ipc: kernel::ipc::IPC<{ NUM_PROCS as u8 }>,
+    analog_comparator: &'static capsules::analog_comparator::AnalogComparator<
+        'static,
+        nrf52840::acomp::Comparator<'static>,
+    >,
+    alarm: &'static capsules::alarm::AlarmDriver<
+        'static,
+        capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52840::rtc::Rtc<'static>>,
+    >,
+    // maybe remove those if problems occur
+    scheduler: &'static RoundRobinSched<'static>,
+    systick: cortexm4::systick::SysTick,
+    nvmc: &'static nrf52840::nvmc::SyscallDriver,
+    usb: &'static capsules::usb::usb_ctap::CtapUsbSyscallDriver<
+        'static,
+        'static,
+        nrf52840::usbd::Usbd<'static>,
+    >,
+    // not backported yet
+    //crp: &'static capsules::firmware_protection::FirmwareProtection<nrf52840::uicr::Uicr>,
+}
+
+impl SyscallDriverLookup for Platform {
+    fn with_driver<F, R>(&self, driver_num: usize, f: F) -> R
+    where
+        F: FnOnce(Option<&dyn kernel::syscall::SyscallDriver>) -> R,
+    {
+        match driver_num {
+            capsules::console::DRIVER_NUM => f(Some(self.console)),
+            capsules::gpio::DRIVER_NUM => f(Some(self.gpio)),
+            capsules::alarm::DRIVER_NUM => f(Some(self.alarm)),
+            capsules::led::DRIVER_NUM => f(Some(self.led)),
+            capsules::button::DRIVER_NUM => f(Some(self.button)),
+            capsules::rng::DRIVER_NUM => f(Some(self.rng)),
+            capsules::analog_comparator::DRIVER_NUM => f(Some(self.analog_comparator)),
+            nrf52840::nvmc::DRIVER_NUM => f(Some(self.nvmc)),
+            capsules::usb::usb_ctap::DRIVER_NUM => f(Some(self.usb)),
+            // not backported yet
+            // capsules::firmware_protection::DRIVER_NUM => f(Some(self.crp)),
+            kernel::ipc::DRIVER_NUM => f(Some(&self.ipc)),
+            _ => f(None),
+        }
+    }
+}
+
+impl SyscallFilter for Platform {
+    fn filter_syscall(
+        &self,
+        process: &dyn kernel::process::Process,
+        syscall: &kernel::syscall::Syscall,
+    ) -> Result<(), kernel::errorcode::ErrorCode> {
+        use kernel::syscall::Syscall;
+        match *syscall {
+            Syscall::Command {
+                driver_number: nrf52840::nvmc::DRIVER_NUM,
+                subdriver_number: cmd,
+                arg0: ptr,
+                arg1: len,
+            } if (cmd == 2 || cmd == 3) && !process.fits_in_storage_location(ptr, len) => {
+                Err(kernel::ErrorCode::INVAL)
+            }
+            _ => Ok(()),
+        }
+    }
+}
+
+impl KernelResources<nrf52840::chip::NRF52<'static, Nrf52840DefaultPeripherals<'static>>>
+    for Platform
+{
+    type SyscallDriverLookup = Self;
+    type SyscallFilter = ();
+    type ProcessFault = ();
+    type CredentialsCheckingPolicy = ();
+    type Scheduler = RoundRobinSched<'static>;
+    type SchedulerTimer = cortexm4::systick::SysTick;
+    type WatchDog = ();
+    type ContextSwitchCallback = ();
+
+    fn syscall_driver_lookup(&self) -> &Self::SyscallDriverLookup {
+        &self
+    }
+    fn syscall_filter(&self) -> &Self::SyscallFilter {
+        &()
+    }
+    fn process_fault(&self) -> &Self::ProcessFault {
+        &()
+    }
+    fn credentials_checking_policy(&self) -> &'static Self::CredentialsCheckingPolicy {
+        &()
+    }
+    fn scheduler(&self) -> &Self::Scheduler {
+        self.scheduler
+    }
+    fn scheduler_timer(&self) -> &Self::SchedulerTimer {
+        &self.systick
+    }
+    fn watchdog(&self) -> &Self::WatchDog {
+        &()
+    }
+    fn context_switch_callback(&self) -> &Self::ContextSwitchCallback {
+        &()
+    }
+}
+
+/// This is in a separate, inline(never) function so that its stack frame is
+/// removed when this function returns. Otherwise, the stack space used for
+/// these static_inits is wasted.
+#[inline(never)]
+unsafe fn get_peripherals() -> &'static mut Nrf52840DefaultPeripherals<'static> {
+    // Initialize chip peripheral drivers
+    let nrf52840_peripherals = static_init!(
+        Nrf52840DefaultPeripherals,
+        Nrf52840DefaultPeripherals::new()
+    );
+
+    nrf52840_peripherals
+}
+
+/// Main function called after RAM initialized.
+#[no_mangle]
+pub unsafe fn main() {
+    nrf52840::init();
+
+    let nrf52840_peripherals = get_peripherals();
+
+    // set up circular peripheral dependencies
+    nrf52840_peripherals.init();
+    let base_peripherals = &nrf52840_peripherals.nrf52;
+
+    // let board_kernel = static_init!(kernel::Kernel, kernel::Kernel::new(&PROCESSES));
+    let board_kernel = static_init!(
+        kernel::Kernel,
+        kernel::Kernel::new_with_storage(&PROCESSES, &STORAGE_LOCATIONS)
+    );
+
+    // GPIOs
+    let gpio = components::gpio::GpioComponent::new(
+        board_kernel,
+        capsules::gpio::DRIVER_NUM,
+        components::gpio_component_helper!(
+            nrf52840::gpio::GPIOPin,
+            // left side of the USB plug
+            0 => &nrf52840_peripherals.gpio_port[Pin::P0_13],
+            1 => &nrf52840_peripherals.gpio_port[Pin::P0_15],
+            2 => &nrf52840_peripherals.gpio_port[Pin::P0_17],
+            3 => &nrf52840_peripherals.gpio_port[Pin::P0_20],
+            4 => &nrf52840_peripherals.gpio_port[Pin::P0_22],
+            5 => &nrf52840_peripherals.gpio_port[Pin::P0_24],
+            6 => &nrf52840_peripherals.gpio_port[Pin::P1_00],
+            7 => &nrf52840_peripherals.gpio_port[Pin::P0_09],
+            8 => &nrf52840_peripherals.gpio_port[Pin::P0_10],
+            // right side of the USB plug
+            9 => &nrf52840_peripherals.gpio_port[Pin::P0_31],
+            10 => &nrf52840_peripherals.gpio_port[Pin::P0_29],
+            11 => &nrf52840_peripherals.gpio_port[Pin::P0_02],
+            12 => &nrf52840_peripherals.gpio_port[Pin::P1_15],
+            13 => &nrf52840_peripherals.gpio_port[Pin::P1_13],
+            14 => &nrf52840_peripherals.gpio_port[Pin::P1_10],
+            // Below the PCB
+            15 => &nrf52840_peripherals.gpio_port[Pin::P0_26],
+            16 => &nrf52840_peripherals.gpio_port[Pin::P0_04],
+            17 => &nrf52840_peripherals.gpio_port[Pin::P0_11],
+            18 => &nrf52840_peripherals.gpio_port[Pin::P0_14],
+            19 => &nrf52840_peripherals.gpio_port[Pin::P1_11],
+            20 => &nrf52840_peripherals.gpio_port[Pin::P1_07],
+            21 => &nrf52840_peripherals.gpio_port[Pin::P1_01],
+            22 => &nrf52840_peripherals.gpio_port[Pin::P1_04],
+            23 => &nrf52840_peripherals.gpio_port[Pin::P1_02]
+        ),
+    )
+    .finalize(components::gpio_component_static!(nrf52840::gpio::GPIOPin));
+
+    let button = components::button::ButtonComponent::new(
+        board_kernel,
+        capsules::button::DRIVER_NUM,
+        components::button_component_helper!(
+            nrf52840::gpio::GPIOPin,
+            (
+                &nrf52840_peripherals.gpio_port[BUTTON_PIN],
+                kernel::hil::gpio::ActivationMode::ActiveLow,
+                kernel::hil::gpio::FloatingState::PullUp
+            )
+        ),
+    )
+    .finalize(components::button_component_static!(
+        nrf52840::gpio::GPIOPin
+    ));
+
+    let led = components::led::LedsComponent::new().finalize(components::led_component_static!(
+        LedLow<'static, nrf52840::gpio::GPIOPin>,
+        LedLow::new(&nrf52840_peripherals.gpio_port[LED1_PIN]),
+        LedLow::new(&nrf52840_peripherals.gpio_port[LED2_R_PIN]),
+        LedLow::new(&nrf52840_peripherals.gpio_port[LED2_G_PIN]),
+        LedLow::new(&nrf52840_peripherals.gpio_port[LED2_B_PIN]),
+    ));
+
+    let chip = static_init!(
+        nrf52840::chip::NRF52<Nrf52840DefaultPeripherals>,
+        nrf52840::chip::NRF52::new(nrf52840_peripherals)
+    );
+    CHIP = Some(chip);
+
+    nrf52_components::startup::NrfStartupComponent::new(
+        false,
+        BUTTON_RST_PIN,
+        nrf52840::uicr::Regulator0Output::V3_0,
+        &base_peripherals.nvmc,
+    )
+    .finalize(());
+
+    // Create capabilities that the board needs to call certain protected kernel
+    // functions.
+    let process_management_capability =
+        create_capability!(capabilities::ProcessManagementCapability);
+    let main_loop_capability = create_capability!(capabilities::MainLoopCapability);
+    let memory_allocation_capability = create_capability!(capabilities::MemoryAllocationCapability);
+
+    let gpio_port = &nrf52840_peripherals.gpio_port;
+
+    // Configure kernel debug gpios as early as possible
+    kernel::debug::assign_gpios(
+        Some(&gpio_port[LED2_R_PIN]),
+        Some(&gpio_port[LED2_G_PIN]),
+        Some(&gpio_port[LED2_B_PIN]),
+    );
+
+    let rtc = &base_peripherals.rtc;
+    let _ = rtc.start();
+    let mux_alarm = components::alarm::AlarmMuxComponent::new(rtc)
+        .finalize(components::alarm_mux_component_static!(nrf52840::rtc::Rtc));
+    let alarm = components::alarm::AlarmDriverComponent::new(
+        board_kernel,
+        capsules::alarm::DRIVER_NUM,
+        mux_alarm,
+    )
+    .finalize(components::alarm_component_static!(nrf52840::rtc::Rtc));
+    let uart_channel = UartChannel::Pins(UartPins::new(UART_RTS, UART_TXD, UART_CTS, UART_RXD));
+    let channel = nrf52_components::UartChannelComponent::new(
+        uart_channel,
+        mux_alarm,
+        &base_peripherals.uarte0,
+    )
+    .finalize(nrf52_components::uart_channel_component_static!(
+        nrf52840::rtc::Rtc
+    ));
+
+    let dynamic_deferred_call_clients =
+        static_init!([DynamicDeferredCallClientState; 3], Default::default());
+    let dynamic_deferred_caller = static_init!(
+        DynamicDeferredCall,
+        DynamicDeferredCall::new(dynamic_deferred_call_clients)
+    );
+    DynamicDeferredCall::set_global_instance(dynamic_deferred_caller);
+
+    let process_printer = components::process_printer::ProcessPrinterTextComponent::new()
+        .finalize(components::process_printer_text_component_static!());
+    PROCESS_PRINTER = Some(process_printer);
+
+    // Create a shared UART channel for the console and for kernel debug.
+    let uart_mux =
+        components::console::UartMuxComponent::new(channel, 115200, dynamic_deferred_caller)
+            .finalize(components::uart_mux_component_static!());
+
+    let pconsole = components::process_console::ProcessConsoleComponent::new(
+        board_kernel,
+        uart_mux,
+        mux_alarm,
+        process_printer,
+    )
+    .finalize(components::process_console_component_static!(
+        nrf52840::rtc::Rtc<'static>
+    ));
+
+    // Setup the console.
+    let console = components::console::ConsoleComponent::new(
+        board_kernel,
+        capsules::console::DRIVER_NUM,
+        uart_mux,
+    )
+    .finalize(components::console_component_static!());
+    // Create the debugger object that handles calls to `debug!()`.
+    components::debug_writer::DebugWriterComponent::new(uart_mux)
+        .finalize(components::debug_writer_component_static!());
+
+    let rng = components::rng::RngComponent::new(
+        board_kernel,
+        capsules::rng::DRIVER_NUM,
+        &base_peripherals.trng,
+    )
+    .finalize(components::rng_component_static!());
+
+    // Initialize AC using AIN5 (P0.29) as VIN+ and VIN- as AIN0 (P0.02)
+    // These are hardcoded pin assignments specified in the driver
+    let analog_comparator = components::analog_comparator::AnalogComparatorComponent::new(
+        &base_peripherals.acomp,
+        components::analog_comparator_component_helper!(
+            nrf52840::acomp::Channel,
+            &nrf52840::acomp::CHANNEL_AC0
+        ),
+        board_kernel,
+        capsules::analog_comparator::DRIVER_NUM,
+    )
+    .finalize(components::analog_comparator_component_static!(
+        nrf52840::acomp::Comparator
+    ));
+
+    let nvmc = static_init!(
+        nrf52840::nvmc::SyscallDriver,
+        nrf52840::nvmc::SyscallDriver::new(
+            &base_peripherals.nvmc,
+            board_kernel.create_grant(nrf52840::nvmc::DRIVER_NUM, &memory_allocation_capability),
+            dynamic_deferred_caller,
+        )
+    );
+    nvmc.set_deferred_handle(
+        dynamic_deferred_caller
+            .register(nvmc)
+            .expect("no deferred call slot available for nvmc"),
+    );
+    // Configure USB controller
+    let usb = components::usb_ctap::UsbCtapComponent::new(
+        board_kernel,
+        capsules::usb::usb_ctap::DRIVER_NUM,
+        &nrf52840_peripherals.usbd,
+        capsules::usb::usbc_client::MAX_CTRL_PACKET_SIZE_NRF52840,
+        VENDOR_ID,
+        PRODUCT_ID,
+        STRINGS,
+    )
+    .finalize(components::usb_ctap_component_buf!(nrf52840::usbd::Usbd));
+
+    // not backported yet
+    // let crp = components::firmware_protection::FirmwareProtectionComponent::new(
+    //     board_kernel,
+    //     nrf52840::uicr::Uicr::new(),
+    // )
+    // .finalize(components::firmware_protection_component_helper!(
+    //     nrf52840::uicr::Uicr
+    // ));
+
+    nrf52_components::NrfClockComponent::new(&base_peripherals.clock).finalize(());
+
+    let scheduler = components::sched::round_robin::RoundRobinComponent::new(&PROCESSES)
+        .finalize(components::round_robin_component_static!(NUM_PROCS));
+
+    let platform = Platform {
+        button,
+        pconsole,
+        console,
+        led,
+        gpio,
+        rng,
+        alarm,
+        analog_comparator,
+        nvmc,
+        usb,
+        //crp
+        ipc: kernel::ipc::IPC::new(
+            board_kernel,
+            kernel::ipc::DRIVER_NUM,
+            &memory_allocation_capability,
+        ),
+        scheduler,
+        systick: cortexm4::systick::SysTick::new_with_calibration(64000000),
+    };
+
+    let _ = platform.pconsole.start();
+    debug!("Initialization complete. Entering main loop\r");
+    debug!("{}", &nrf52840::ficr::FICR_INSTANCE);
+
+    // These symbols are defined in the linker script.
+    extern "C" {
+        /// Beginning of the ROM region containing app images.
+        static _sapps: u8;
+        /// End of the ROM region containing app images.
+        static _eapps: u8;
+        /// Beginning of the RAM region for app memory.
+        static mut _sappmem: u8;
+        /// End of the RAM region for app memory.
+        static _eappmem: u8;
+    }
+
+    kernel::process::load_processes(
+        board_kernel,
+        chip,
+        core::slice::from_raw_parts(
+            &_sapps as *const u8,
+            &_eapps as *const u8 as usize - &_sapps as *const u8 as usize,
+        ),
+        core::slice::from_raw_parts_mut(
+            &mut _sappmem as *mut u8,
+            &_eappmem as *const u8 as usize - &_sappmem as *const u8 as usize,
+        ),
+        &mut PROCESSES,
+        &FAULT_RESPONSE,
+        &process_management_capability,
+    )
+    .unwrap_or_else(|err| {
+        debug!("Error loading processes!");
+        debug!("{:?}", err);
+    });
+
+    board_kernel.kernel_loop(&platform, chip, Some(&platform.ipc), &main_loop_capability);
+}
diff --git a/kernel/src/lib.rs b/kernel/src/lib.rs
index 25ae781d1..02507d340 100644
--- a/kernel/src/lib.rs
+++ b/kernel/src/lib.rs
@@ -126,5 +126,6 @@ mod syscall_driver;
 // Core resources exposed as `kernel::Type`.
 pub use crate::errorcode::ErrorCode;
 pub use crate::kernel::Kernel;
+pub use crate::kernel::{StorageLocation, StorageType};
 pub use crate::process::ProcessId;
 pub use crate::scheduler::Scheduler;
-- 
2.34.1


From 5d8f8f5336ac3b79a9684af02a444b4cfd45d75b Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Fri, 11 Nov 2022 15:49:42 +0100
Subject: [PATCH 13/27] Match subscribe nrs of upcalls to nrs of processes

---
 capsules/src/usb/usb_ctap.rs | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index 0956550c4..3c3b54fe3 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -31,8 +31,9 @@ pub const CTAP_SUBSCRIBE_RECEIVE: usize = 2;
 pub const CTAP_SUBSCRIBE_TRANSMIT_OR_RECEIVE: usize = 3;
 
 // the different kinds of subscribe upcalls triggered inside the application when the corresponding event happens
-pub const CTAP_CALLBACK_TRANSMITED_SUBSCRIBE_NUM: usize = 0;
-pub const CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM: usize = 1;
+// they need to match the corresponding subscribe nrs which were used by the process
+pub const CTAP_CALLBACK_TRANSMITED_SUBSCRIBE_NUM: usize = CTAP_SUBSCRIBE_TRANSMIT;
+pub const CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM: usize = CTAP_SUBSCRIBE_RECEIVE;
 
 type CtabUsbDriverGrant = Grant<App, UpcallCount<2>, AllowRoCount<1>, AllowRwCount<1>>;
 
-- 
2.34.1


From 31baf31a900bed4abc9f8d67117c19be7c556c6c Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Fri, 11 Nov 2022 17:19:25 +0100
Subject: [PATCH 14/27] Remove TODO comments

---
 capsules/src/usb/usb_ctap.rs | 2 --
 1 file changed, 2 deletions(-)

diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index 3c3b54fe3..d0bc6c7b6 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -19,12 +19,10 @@ pub const CTAP_CMD_RECEIVE: usize = 3;
 pub const CTAP_CMD_TRANSMIT_OR_RECEIVE: usize = 4;
 pub const CTAP_CMD_CANCEL: usize = 5;
 
-// todo: figure out what do with them
 pub const CTAP_ALLOW_TRANSMIT: usize = 1;
 pub const CTAP_ALLOW_RECEIVE: usize = 2;
 pub const CTAP_ALLOW_TRANSMIT_OR_RECEIVE: usize = 3;
 
-// todo: figure out what do with them
 // ids for the subscribe syscalls
 pub const CTAP_SUBSCRIBE_TRANSMIT: usize = 1;
 pub const CTAP_SUBSCRIBE_RECEIVE: usize = 2;
-- 
2.34.1


From 1ef0f2c14cf9a724290177d5ed700a5b8c836669 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Sun, 20 Nov 2022 15:22:46 +0100
Subject: [PATCH 15/27] Revise grant type and allow numbers

---
 capsules/src/usb/usb_ctap.rs | 47 +++++++++++++++++++++++-------------
 1 file changed, 30 insertions(+), 17 deletions(-)

diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index d0bc6c7b6..f3b22a849 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -19,21 +19,34 @@ pub const CTAP_CMD_RECEIVE: usize = 3;
 pub const CTAP_CMD_TRANSMIT_OR_RECEIVE: usize = 4;
 pub const CTAP_CMD_CANCEL: usize = 5;
 
-pub const CTAP_ALLOW_TRANSMIT: usize = 1;
-pub const CTAP_ALLOW_RECEIVE: usize = 2;
-pub const CTAP_ALLOW_TRANSMIT_OR_RECEIVE: usize = 3;
+/// Ids for read-only allow buffers
+mod ro_allow {
+    pub const TRANSMIT: usize = 0;
+    pub const TRANSMIT_OR_RECEIVE: usize = 1;
+    pub const COUNT: u8 = 2;
+}
 
-// ids for the subscribe syscalls
-pub const CTAP_SUBSCRIBE_TRANSMIT: usize = 1;
-pub const CTAP_SUBSCRIBE_RECEIVE: usize = 2;
-pub const CTAP_SUBSCRIBE_TRANSMIT_OR_RECEIVE: usize = 3;
+/// Ids for read-write allow buffers
+mod rw_allow {
+    pub const RECEIVE: usize = 0;
+    pub const COUNT: u8 = 1;
+}
 
-// the different kinds of subscribe upcalls triggered inside the application when the corresponding event happens
-// they need to match the corresponding subscribe nrs which were used by the process
-pub const CTAP_CALLBACK_TRANSMITED_SUBSCRIBE_NUM: usize = CTAP_SUBSCRIBE_TRANSMIT;
-pub const CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM: usize = CTAP_SUBSCRIBE_RECEIVE;
+/// Ids for scheduling the upcalls
+///
+/// They **must** match the the subscribe numbers which were used by the process.
+mod upcalls {
+    pub const TRANSMITTED: usize = 0;
+    pub const RECEIVED: usize = 1;
+    pub const COUNT: u8 = 2;
+}
 
-type CtabUsbDriverGrant = Grant<App, UpcallCount<2>, AllowRoCount<1>, AllowRwCount<1>>;
+type CtabUsbDriverGrant = Grant<
+    App,
+    UpcallCount<{ upcalls::COUNT }>,
+    AllowRoCount<{ ro_allow::COUNT }>,
+    AllowRwCount<{ rw_allow::COUNT }>,
+>;
 
 pub trait CtapUsbClient {
     // Whether this client is ready to receive a packet. This must be checked before calling
@@ -67,7 +80,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbSyscallDriver<'a, 'b, C> {
     ) {
         if app.connected && app.waiting && app.side.map_or(false, |side| side.can_receive()) {
             kernel_data
-                .get_readwrite_processbuffer(1)
+                .get_readwrite_processbuffer(rw_allow::RECEIVE)
                 .and_then(|process_buffer| {
                     process_buffer
                         .mut_enter(|buf| buf.copy_from_slice(packet))
@@ -75,7 +88,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbSyscallDriver<'a, 'b, C> {
                     app.waiting = false;
                     // Signal to the app that a packet is ready.
                     kernel_data
-                        .schedule_upcall(CTAP_CALLBACK_RECEIVED_SUBSCRIBE_NUM, (endpoint, 0, 0))
+                        .schedule_upcall(upcalls::RECEIVED, (endpoint, 0, 0))
                         .unwrap();
                     // reset the client state
                     app.check_side();
@@ -124,7 +137,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDri
                     app.waiting = false;
                     // Signal to the app that the packet was sent.
                     kernel_data
-                        .schedule_upcall(CTAP_CALLBACK_TRANSMITED_SUBSCRIBE_NUM, (0, 0, 0))
+                        .schedule_upcall(upcalls::TRANSMITTED, (0, 0, 0))
                         .unwrap();
 
                     // reset the client state
@@ -189,7 +202,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                                 CommandReturn::failure(ErrorCode::ALREADY)
                             } else {
                                 kernel
-                                    .get_readonly_processbuffer(1)
+                                    .get_readonly_processbuffer(ro_allow::TRANSMIT)
                                     .and_then(|buffer| {
                                         buffer.enter(|buf| {
                                             let mut packet: [u8; 64] = [0; 64];
@@ -253,7 +266,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                             } else {
                                 // send a packet before receiving one
                                 let r = kernel
-                                    .get_readonly_processbuffer(1)
+                                    .get_readonly_processbuffer(ro_allow::TRANSMIT_OR_RECEIVE)
                                     .and_then(|process_buffer| {
                                         process_buffer.enter(|buf| {
                                             let mut packet: [u8; 64] = [0; 64];
-- 
2.34.1


From 45b2b1abe186ed2e3dcaea786516a09bcee619c8 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Wed, 30 Nov 2022 16:12:57 +0100
Subject: [PATCH 16/27] Update nrf52840_dongle linker script

---
 boards/nordic/nrf52840_dongle_dfu/layout.ld | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/boards/nordic/nrf52840_dongle_dfu/layout.ld b/boards/nordic/nrf52840_dongle_dfu/layout.ld
index 41ae608ac..bb6927b7b 100644
--- a/boards/nordic/nrf52840_dongle_dfu/layout.ld
+++ b/boards/nordic/nrf52840_dongle_dfu/layout.ld
@@ -5,6 +5,5 @@ MEMORY
   ram (rwx) : ORIGIN = 0x20000000, LENGTH = 256K
 }
 
-MPU_MIN_ALIGN = 8K;
-
+PAGE_SIZE = 4K;
 INCLUDE ../../kernel_layout.ld
-- 
2.34.1


From 5d30ec71de7bd138ce78874df64c80c245986b1e Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Wed, 7 Dec 2022 18:50:56 +0100
Subject: [PATCH 17/27] Enable debug_load_processes for opentitan

This also uses the lowrisc opentitan patched version of the riscv
toolchain.
---
 boards/opentitan/earlgrey-cw310/Cargo.toml | 2 +-
 boards/opentitan/earlgrey-cw310/Makefile   | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/boards/opentitan/earlgrey-cw310/Cargo.toml b/boards/opentitan/earlgrey-cw310/Cargo.toml
index afe580bbd..ea8063841 100644
--- a/boards/opentitan/earlgrey-cw310/Cargo.toml
+++ b/boards/opentitan/earlgrey-cw310/Cargo.toml
@@ -9,7 +9,7 @@ edition.workspace = true
 components = { path = "../../components" }
 rv32i = { path = "../../../arch/rv32i" }
 capsules = { path = "../../../capsules" }
-kernel = { path = "../../../kernel" }
+kernel = { path = "../../../kernel", features = ["debug_load_processes"] }
 earlgrey = { path = "../../../chips/earlgrey" }
 lowrisc = { path = "../../../chips/lowrisc" }
 tock-tbf = { path = "../../../libraries/tock-tbf" }
diff --git a/boards/opentitan/earlgrey-cw310/Makefile b/boards/opentitan/earlgrey-cw310/Makefile
index 7ae1c4fd4..648d4f0b0 100644
--- a/boards/opentitan/earlgrey-cw310/Makefile
+++ b/boards/opentitan/earlgrey-cw310/Makefile
@@ -4,7 +4,7 @@ DEFAULT_BOARD_CONFIGURATION=fpga_cw310
 TARGET=riscv32imc-unknown-none-elf
 PLATFORM=earlgrey-cw310
 FLASHID=--dev-id="0403:6010"
-RISC_PREFIX ?= riscv64-linux-gnu
+RISC_PREFIX ?= $(TOOLCHAIN_PATH)/bin/riscv32-unknown-elf
 QEMU ?= ../../../tools/qemu/build/qemu-system-riscv32
 # Override for the entry point
 # This offset is calculated (from the linker file) as:
-- 
2.34.1


From e211c5e8bb63c7211364ae45c095d4f7eb7c83fe Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Wed, 7 Dec 2022 20:09:41 +0100
Subject: [PATCH 18/27] Add nrf52840dk_opensk custom board for OpenSK

---
 Cargo.toml                                    |   1 +
 boards/nordic/nrf52840dk_opensk/Cargo.toml    |  17 +
 boards/nordic/nrf52840dk_opensk/Makefile      |  31 +
 boards/nordic/nrf52840dk_opensk/README.md     |  65 ++
 boards/nordic/nrf52840dk_opensk/build.rs      |  29 +
 .../jtag/gdbinit_pca10040.jlink               |  25 +
 .../jtag/jdbserver_pca10040.sh                |   1 +
 boards/nordic/nrf52840dk_opensk/layout.ld     |   2 +
 boards/nordic/nrf52840dk_opensk/src/io.rs     | 108 ++++
 boards/nordic/nrf52840dk_opensk/src/main.rs   | 583 ++++++++++++++++++
 10 files changed, 862 insertions(+)
 create mode 100644 boards/nordic/nrf52840dk_opensk/Cargo.toml
 create mode 100644 boards/nordic/nrf52840dk_opensk/Makefile
 create mode 100644 boards/nordic/nrf52840dk_opensk/README.md
 create mode 100644 boards/nordic/nrf52840dk_opensk/build.rs
 create mode 100644 boards/nordic/nrf52840dk_opensk/jtag/gdbinit_pca10040.jlink
 create mode 100755 boards/nordic/nrf52840dk_opensk/jtag/jdbserver_pca10040.sh
 create mode 100644 boards/nordic/nrf52840dk_opensk/layout.ld
 create mode 100644 boards/nordic/nrf52840dk_opensk/src/io.rs
 create mode 100644 boards/nordic/nrf52840dk_opensk/src/main.rs

diff --git a/Cargo.toml b/Cargo.toml
index 503769e2c..c9903746a 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -24,6 +24,7 @@ members = [
     "boards/msp_exp432p401r",
     "boards/microbit_v2",
     "boards/nordic/nrf52840dk",
+    "boards/nordic/nrf52840dk_opensk",
     "boards/nordic/nrf52840_dongle",
     "boards/nordic/nrf52840_dongle_opensk",
     "boards/nordic/nrf52840_dongle_dfu",
diff --git a/boards/nordic/nrf52840dk_opensk/Cargo.toml b/boards/nordic/nrf52840dk_opensk/Cargo.toml
new file mode 100644
index 000000000..03d6f1d15
--- /dev/null
+++ b/boards/nordic/nrf52840dk_opensk/Cargo.toml
@@ -0,0 +1,17 @@
+[package]
+name = "nrf52840dk_opensk"
+version = "0.1.0"
+authors = ["Tock Project Developers <tock-dev@googlegroups.com>"]
+build = "build.rs"
+edition = "2018"
+
+[dependencies]
+components = { path = "../../components" }
+cortexm4 = { path = "../../../arch/cortex-m4" }
+capsules = { path = "../../../capsules" }
+kernel = { path = "../../../kernel" }
+nrf52840 = { path = "../../../chips/nrf52840" }
+nrf52_components = { path = "../nrf52_components" }
+
+[features]
+vendor_hid = ["capsules/vendor_hid"]
diff --git a/boards/nordic/nrf52840dk_opensk/Makefile b/boards/nordic/nrf52840dk_opensk/Makefile
new file mode 100644
index 000000000..aec4fe109
--- /dev/null
+++ b/boards/nordic/nrf52840dk_opensk/Makefile
@@ -0,0 +1,31 @@
+# Makefile for building the tock kernel for the nRF development kit
+
+TARGET=thumbv7em-none-eabi
+PLATFORM=nrf52840dk_opensk
+
+include ../../Makefile.common
+
+TOCKLOADER=tockloader
+
+# Where in the SAM4L flash to load the kernel with `tockloader`
+KERNEL_ADDRESS=0x00000
+
+# Upload programs over uart with tockloader
+ifdef PORT
+  TOCKLOADER_GENERAL_FLAGS += --port $(PORT)
+endif
+
+# Upload the kernel over JTAG
+.PHONY: flash
+flash: $(TOCK_ROOT_DIRECTORY)target/$(TARGET)/release/$(PLATFORM).bin
+	$(TOCKLOADER) $(TOCKLOADER_GENERAL_FLAGS) flash --address $(KERNEL_ADDRESS) --board nrf52dk --jlink $<
+
+# Upload the kernel over JTAG using OpenOCD
+.PHONY: flash-openocd
+flash-openocd: $(TOCK_ROOT_DIRECTORY)target/$(TARGET)/release/$(PLATFORM).bin
+	$(TOCKLOADER) $(TOCKLOADER_GENERAL_FLAGS) flash --address $(KERNEL_ADDRESS) --board nrf52dk --openocd $<
+
+# Upload the kernel over serial/bootloader
+.PHONY: program
+program: $(TOCK_ROOT_DIRECTORY)target/$(TARGET)/release/$(PLATFORM).hex
+	$(error Cannot program nRF52840DK over USB. Use \`make flash\` and JTAG)
diff --git a/boards/nordic/nrf52840dk_opensk/README.md b/boards/nordic/nrf52840dk_opensk/README.md
new file mode 100644
index 000000000..81c0fe2e5
--- /dev/null
+++ b/boards/nordic/nrf52840dk_opensk/README.md
@@ -0,0 +1,65 @@
+Platform-Specific Instructions: nRF52840-DK
+===================================
+
+This is an adapted nrf52840dk made to work with OpenSK.
+
+The [nRF52840 Development
+Kit](https://www.nordicsemi.com/Software-and-Tools/Development-Kits/nRF52840-DK) is a platform
+based around the nRF52840, an SoC with an ARM Cortex-M4 and a BLE
+radio. The kit is Arduino shield compatible and includes several
+buttons.
+
+## Getting Started
+
+First, follow the [Tock Getting Started guide](../../../doc/Getting_Started.md)
+
+JTAG is the preferred method to program. The development kit has an
+integrated JTAG debugger, you simply need to [install JTAG
+software](../../../doc/Getting_Started.md#loading-the-kernel-onto-a-board).
+
+## Programming the kernel
+Once you have all software installed, you should be able to simply run
+make flash in this directory to install a fresh kernel.
+
+## Programming user-level applications
+You can program an application over USB using the integrated JTAG and `tockloader`:
+
+```bash
+$ cd libtock-c/examples/<app>
+$ make
+$ tockloader install --jlink --board nrf52dk
+```
+
+The same options (`--jlink --board nrf52dk`) must be passed for other tockloader commands
+such as `erase-apps` or `list`.
+
+Viewing console output on the nrf52840dk is slightly different from other boards. You must use
+```bash
+$ tockloader listen
+```
+**followed by a press of the reset button** in order to view console output starting from the boot
+sequence. Notably, you should not
+pass the `--jlink` option to `tockloader listen`.
+
+## Console output
+
+This board supports two methods for writing messages to a console interface
+(console driver for applications as well as debug statements in the kernel).
+
+By default, messages are written to a UART interface over the GPIO pins `P0.05`
+to `P0.08` (see the [main.rs](src/main.rs) file).
+
+If you don't have any UART cables or want to use a different interface, there is
+also a console over the Segger RTT protocol. This only requires a micro-USB
+cable on the USB debugging port (the same used to flash Tock on the board), and
+is enabled by setting the `USB_DEBUGGING` constant to `true` in the
+[main.rs](src/main.rs) file.
+This disables the UART interface.
+
+For instructions about how to receive RTT messages on the host, see the
+[corresponding capsule](../../../capsules/src/segger_rtt.rs).
+
+## Debugging
+
+See the [nrf52dk README](../nrf52dk/README.md) for information about debugging
+the nRF52840dk.
diff --git a/boards/nordic/nrf52840dk_opensk/build.rs b/boards/nordic/nrf52840dk_opensk/build.rs
new file mode 100644
index 000000000..7207fabe7
--- /dev/null
+++ b/boards/nordic/nrf52840dk_opensk/build.rs
@@ -0,0 +1,29 @@
+use std::env;
+use std::fs;
+use std::path::Path;
+
+fn main() {
+    println!("cargo:rerun-if-changed=layout.ld");
+    println!("cargo:rerun-if-changed=../../kernel_layout.ld");
+
+    let out_dir = env::var_os("OUT_DIR").unwrap();
+    let dest_path = Path::new(&out_dir).join("locations.rs");
+    fs::write(
+        &dest_path,
+        "
+static mut STORAGE_LOCATIONS: [kernel::StorageLocation; 2] = [
+    // We implement NUM_PAGES = 20 as 16 + 4 to satisfy the MPU.
+    kernel::StorageLocation {
+        address: 0xC0000,
+        size: 0x10000, // 16 pages
+        storage_type: kernel::StorageType::Store,
+    },
+    kernel::StorageLocation {
+        address: 0xD0000,
+        size: 0x4000, // 4 pages
+        storage_type: kernel::StorageType::Store,
+    },
+];
+"
+    ).unwrap();
+}
diff --git a/boards/nordic/nrf52840dk_opensk/jtag/gdbinit_pca10040.jlink b/boards/nordic/nrf52840dk_opensk/jtag/gdbinit_pca10040.jlink
new file mode 100644
index 000000000..a4f21737b
--- /dev/null
+++ b/boards/nordic/nrf52840dk_opensk/jtag/gdbinit_pca10040.jlink
@@ -0,0 +1,25 @@
+#
+#
+#
+# J-LINK GDB SERVER initialization
+#
+# This connects to a GDB Server listening
+# for commands on localhost at tcp port 2331
+target remote localhost:2331
+monitor speed 30
+file ../../../../target/thumbv7em-none-eabi/release/nrf52dk
+monitor reset
+#
+# CPU core initialization (to be done by user)
+#
+# Set the processor mode
+# monitor reg cpsr = 0xd3
+# Set auto JTAG speed
+monitor speed auto
+# Setup GDB FOR FASTER DOWNLOADS
+set remote memory-write-packet-size 1024
+set remote memory-write-packet-size fixed
+# tui enable
+# layout split
+# layout service_pending_interrupts
+b reset_handler
diff --git a/boards/nordic/nrf52840dk_opensk/jtag/jdbserver_pca10040.sh b/boards/nordic/nrf52840dk_opensk/jtag/jdbserver_pca10040.sh
new file mode 100755
index 000000000..b4bee90e5
--- /dev/null
+++ b/boards/nordic/nrf52840dk_opensk/jtag/jdbserver_pca10040.sh
@@ -0,0 +1 @@
+JLinkGDBServer -device nrf52 -speed 1200 -if swd -AutoConnect 1 -port 2331
diff --git a/boards/nordic/nrf52840dk_opensk/layout.ld b/boards/nordic/nrf52840dk_opensk/layout.ld
new file mode 100644
index 000000000..a8da37599
--- /dev/null
+++ b/boards/nordic/nrf52840dk_opensk/layout.ld
@@ -0,0 +1,2 @@
+INCLUDE ../nrf52840_chip_layout.ld
+INCLUDE ../../kernel_layout.ld
diff --git a/boards/nordic/nrf52840dk_opensk/src/io.rs b/boards/nordic/nrf52840dk_opensk/src/io.rs
new file mode 100644
index 000000000..a3aa356e7
--- /dev/null
+++ b/boards/nordic/nrf52840dk_opensk/src/io.rs
@@ -0,0 +1,108 @@
+use core::fmt::Write;
+use core::panic::PanicInfo;
+use cortexm4;
+use kernel::debug;
+use kernel::debug::IoWrite;
+use kernel::hil::led;
+use kernel::hil::uart;
+use kernel::hil::uart::Configure;
+use nrf52840::gpio::Pin;
+
+use crate::CHIP;
+use crate::PROCESSES;
+use crate::PROCESS_PRINTER;
+
+enum Writer {
+    WriterUart(/* initialized */ bool),
+    WriterRtt(&'static capsules::segger_rtt::SeggerRttMemory<'static>),
+}
+
+static mut WRITER: Writer = Writer::WriterUart(false);
+
+fn wait() {
+    for _ in 0..100 {
+        cortexm4::support::nop();
+    }
+}
+
+/// Set the RTT memory buffer used to output panic messages.
+pub unsafe fn set_rtt_memory(
+    rtt_memory: &'static mut capsules::segger_rtt::SeggerRttMemory<'static>,
+) {
+    WRITER = Writer::WriterRtt(rtt_memory);
+}
+
+impl Write for Writer {
+    fn write_str(&mut self, s: &str) -> ::core::fmt::Result {
+        self.write(s.as_bytes());
+        Ok(())
+    }
+}
+
+impl IoWrite for Writer {
+    fn write(&mut self, buf: &[u8]) {
+        match self {
+            Writer::WriterUart(ref mut initialized) => {
+                // Here, we create a second instance of the Uarte struct.
+                // This is okay because we only call this during a panic, and
+                // we will never actually process the interrupts
+                let uart = nrf52840::uart::Uarte::new();
+                if !*initialized {
+                    *initialized = true;
+                    let _ = uart.configure(uart::Parameters {
+                        baud_rate: 115200,
+                        stop_bits: uart::StopBits::One,
+                        parity: uart::Parity::None,
+                        hw_flow_control: false,
+                        width: uart::Width::Eight,
+                    });
+                }
+                for &c in buf {
+                    unsafe {
+                        uart.send_byte(c);
+                    }
+                    while !uart.tx_ready() {}
+                }
+            }
+            Writer::WriterRtt(rtt_memory) => {
+                let up_buffer = unsafe { &*rtt_memory.get_up_buffer_ptr() };
+                let buffer_len = up_buffer.length.get();
+                let buffer = unsafe {
+                    core::slice::from_raw_parts_mut(
+                        up_buffer.buffer.get() as *mut u8,
+                        buffer_len as usize,
+                    )
+                };
+
+                let mut write_position = up_buffer.write_position.get();
+
+                for &c in buf {
+                    buffer[write_position as usize] = c;
+                    write_position = (write_position + 1) % buffer_len;
+                    up_buffer.write_position.set(write_position);
+                    wait();
+                }
+            }
+        };
+    }
+}
+
+#[cfg(not(test))]
+#[no_mangle]
+#[panic_handler]
+/// Panic handler
+pub unsafe extern "C" fn panic_fmt(pi: &PanicInfo) -> ! {
+    // The nRF52840DK LEDs (see back of board)
+    let led_kernel_pin = &nrf52840::gpio::GPIOPin::new(Pin::P0_13);
+    let led = &mut led::LedLow::new(led_kernel_pin);
+    let writer = &mut WRITER;
+    debug::panic(
+        &mut [led],
+        writer,
+        pi,
+        &cortexm4::support::nop,
+        &PROCESSES,
+        &CHIP,
+        &PROCESS_PRINTER,
+    )
+}
diff --git a/boards/nordic/nrf52840dk_opensk/src/main.rs b/boards/nordic/nrf52840dk_opensk/src/main.rs
new file mode 100644
index 000000000..88baf5024
--- /dev/null
+++ b/boards/nordic/nrf52840dk_opensk/src/main.rs
@@ -0,0 +1,583 @@
+//! Tock kernel for the Nordic Semiconductor nRF52840 development kit (DK).
+//!
+//! It is based on nRF52840 SoC (Cortex M4 core with a BLE transceiver) with
+//! many exported I/O and peripherals.
+//!
+//! Pin Configuration
+//! -------------------
+//!
+//! ### `GPIO`
+//!
+//! | #  | Pin   | Ix | Header | Arduino |
+//! |----|-------|----|--------|---------|
+//! | 0  | P1.01 | 33 | P3 1   | D0      |
+//! | 1  | P1.02 | 34 | P3 2   | D1      |
+//! | 2  | P1.03 | 35 | P3 3   | D2      |
+//! | 3  | P1.04 | 36 | P3 4   | D3      |
+//! | 4  | P1.05 | 37 | P3 5   | D4      |
+//! | 5  | P1.06 | 38 | P3 6   | D5      |
+//! | 6  | P1.07 | 39 | P3 7   | D6      |
+//! | 7  | P1.08 | 40 | P3 8   | D7      |
+//! | 8  | P1.10 | 42 | P4 1   | D8      |
+//! | 9  | P1.11 | 43 | P4 2   | D9      |
+//! | 10 | P1.12 | 44 | P4 3   | D10     |
+//! | 11 | P1.13 | 45 | P4 4   | D11     |
+//! | 12 | P1.14 | 46 | P4 5   | D12     |
+//! | 13 | P1.15 | 47 | P4 6   | D13     |
+//! | 14 | P0.26 | 26 | P4 9   | D14     |
+//! | 15 | P0.27 | 27 | P4 10  | D15     |
+//!
+//! ### `GPIO` / Analog Inputs
+//!
+//! | #  | Pin        | Header | Arduino |
+//! |----|------------|--------|---------|
+//! | 16 | P0.03 AIN1 | P2 1   | A0      |
+//! | 17 | P0.04 AIN2 | P2 2   | A1      |
+//! | 18 | P0.28 AIN4 | P2 3   | A2      |
+//! | 19 | P0.29 AIN5 | P2 4   | A3      |
+//! | 20 | P0.30 AIN6 | P2 5   | A4      |
+//! | 21 | P0.31 AIN7 | P2 6   | A5      |
+//! | 22 | P0.02 AIN0 | P4 8   | AVDD    |
+//!
+//! ### Onboard Functions
+//!
+//! | Pin   | Header | Function |
+//! |-------|--------|----------|
+//! | P0.05 | P6 3   | UART RTS |
+//! | P0.06 | P6 4   | UART TXD |
+//! | P0.07 | P6 5   | UART CTS |
+//! | P0.08 | P6 6   | UART RXT |
+//! | P0.11 | P24 1  | Button 1 |
+//! | P0.12 | P24 2  | Button 2 |
+//! | P0.13 | P24 3  | LED 1    |
+//! | P0.14 | P24 4  | LED 2    |
+//! | P0.15 | P24 5  | LED 3    |
+//! | P0.16 | P24 6  | LED 4    |
+//! | P0.18 | P24 8  | Reset    |
+//! | P0.19 | P24 9  | SPI CLK  |
+//! | P0.20 | P24 10 | SPI MOSI |
+//! | P0.21 | P24 11 | SPI MISO |
+//! | P0.24 | P24 14 | Button 3 |
+//! | P0.25 | P24 15 | Button 4 |
+
+#![no_std]
+// Disable this attribute when documenting, as a workaround for
+// https://github.com/rust-lang/rust/issues/62184.
+#![cfg_attr(not(doc), no_main)]
+#![deny(missing_docs)]
+
+use capsules::virtual_alarm::VirtualMuxAlarm;
+use core::env;
+use kernel::component::Component;
+use kernel::dynamic_deferred_call::{DynamicDeferredCall, DynamicDeferredCallClientState};
+use kernel::hil::led::LedLow;
+use kernel::hil::time::Counter;
+use kernel::platform::{KernelResources, SyscallDriverLookup, SyscallFilter};
+use kernel::scheduler::round_robin::RoundRobinSched;
+#[allow(unused_imports)]
+use kernel::{capabilities, create_capability, debug, debug_gpio, debug_verbose, static_init};
+use nrf52840::gpio::Pin;
+use nrf52840::interrupt_service::Nrf52840DefaultPeripherals;
+use nrf52_components::{self, UartChannel, UartPins};
+
+// The nRF52840DK LEDs (see back of board)
+const LED1_PIN: Pin = Pin::P0_13;
+const LED2_PIN: Pin = Pin::P0_14;
+const LED3_PIN: Pin = Pin::P0_15;
+const LED4_PIN: Pin = Pin::P0_16;
+
+// The nRF52840DK buttons (see back of board)
+const BUTTON1_PIN: Pin = Pin::P0_11;
+const BUTTON2_PIN: Pin = Pin::P0_12;
+const BUTTON3_PIN: Pin = Pin::P0_24;
+const BUTTON4_PIN: Pin = Pin::P0_25;
+const BUTTON_RST_PIN: Pin = Pin::P0_18;
+
+const UART_RTS: Option<Pin> = Some(Pin::P0_05);
+const UART_TXD: Pin = Pin::P0_06;
+const UART_CTS: Option<Pin> = Some(Pin::P0_07);
+const UART_RXD: Pin = Pin::P0_08;
+
+const SPI_MOSI: Pin = Pin::P0_20;
+const SPI_MISO: Pin = Pin::P0_21;
+const SPI_CLK: Pin = Pin::P0_19;
+
+/// Debug Writer
+pub mod io;
+
+// Whether to use UART debugging or Segger RTT (USB) debugging.
+// - Set to false to use UART.
+// - Set to true to use Segger RTT over USB.
+const USB_DEBUGGING: bool = true;
+
+const VENDOR_ID: u16 = 0x1915; // Nordic Semiconductor
+const PRODUCT_ID: u16 = 0x521f; // nRF52840 Dongle (PCA10059)
+static STRINGS: &'static [&'static str] = &[
+    // Manufacturer
+    "Nordic Semiconductor ASA",
+    // Product
+    "OpenSK",
+    // Serial number
+    "v1.0",
+];
+
+// State for loading and holding applications.
+// How should the kernel respond when a process faults.
+const FAULT_RESPONSE: kernel::process::PanicFaultPolicy = kernel::process::PanicFaultPolicy {};
+
+// Number of concurrent processes this platform supports.
+const NUM_PROCS: usize = 8;
+
+static mut PROCESSES: [Option<&'static dyn kernel::process::Process>; NUM_PROCS] =
+    [None; NUM_PROCS];
+
+include!(concat!(env!("OUT_DIR"), "/locations.rs"));
+
+static mut CHIP: Option<&'static nrf52840::chip::NRF52<Nrf52840DefaultPeripherals>> = None;
+static mut PROCESS_PRINTER: Option<&'static kernel::process::ProcessPrinterText> = None;
+
+/// Dummy buffer that causes the linker to reserve enough space for the stack.
+#[no_mangle]
+#[link_section = ".stack_buffer"]
+pub static mut STACK_MEMORY: [u8; 0x2000] = [0; 0x2000];
+
+/// Supported drivers by the platform
+pub struct Platform {
+    button: &'static capsules::button::Button<'static, nrf52840::gpio::GPIOPin<'static>>,
+    pconsole: &'static capsules::process_console::ProcessConsole<
+        'static,
+        VirtualMuxAlarm<'static, nrf52840::rtc::Rtc<'static>>,
+        components::process_console::Capability,
+    >,
+    console: &'static capsules::console::Console<'static>,
+    gpio: &'static capsules::gpio::GPIO<'static, nrf52840::gpio::GPIOPin<'static>>,
+    led: &'static capsules::led::LedDriver<
+        'static,
+        kernel::hil::led::LedLow<'static, nrf52840::gpio::GPIOPin<'static>>,
+        4,
+    >,
+    rng: &'static capsules::rng::RngDriver<'static>,
+    ipc: kernel::ipc::IPC<{ NUM_PROCS as u8 }>,
+    analog_comparator: &'static capsules::analog_comparator::AnalogComparator<
+        'static,
+        nrf52840::acomp::Comparator<'static>,
+    >,
+    alarm: &'static capsules::alarm::AlarmDriver<
+        'static,
+        capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52840::rtc::Rtc<'static>>,
+    >,
+    nvmc: &'static nrf52840::nvmc::SyscallDriver,
+    usb: &'static capsules::usb::usb_ctap::CtapUsbSyscallDriver<
+        'static,
+        'static,
+        nrf52840::usbd::Usbd<'static>,
+    >,
+    scheduler: &'static RoundRobinSched<'static>,
+    systick: cortexm4::systick::SysTick,
+    // disable for now
+    //crp: &'static capsules::firmware_protection::FirmwareProtection<nrf52840::uicr::Uicr>,
+}
+
+impl SyscallDriverLookup for Platform {
+    fn with_driver<F, R>(&self, driver_num: usize, f: F) -> R
+    where
+        F: FnOnce(Option<&dyn kernel::syscall::SyscallDriver>) -> R,
+    {
+        match driver_num {
+            capsules::console::DRIVER_NUM => f(Some(self.console)),
+            capsules::gpio::DRIVER_NUM => f(Some(self.gpio)),
+            capsules::alarm::DRIVER_NUM => f(Some(self.alarm)),
+            capsules::led::DRIVER_NUM => f(Some(self.led)),
+            capsules::button::DRIVER_NUM => f(Some(self.button)),
+            capsules::rng::DRIVER_NUM => f(Some(self.rng)),
+            capsules::analog_comparator::DRIVER_NUM => f(Some(self.analog_comparator)),
+            nrf52840::nvmc::DRIVER_NUM => f(Some(self.nvmc)),
+            capsules::usb::usb_ctap::DRIVER_NUM => f(Some(self.usb)),
+            //capsules::firmware_protection::DRIVER_NUM => f(Some(self.crp)),
+            kernel::ipc::DRIVER_NUM => f(Some(&self.ipc)),
+            _ => f(None),
+        }
+    }
+}
+
+impl SyscallFilter for Platform {
+    fn filter_syscall(
+        &self,
+        process: &dyn kernel::process::Process,
+        syscall: &kernel::syscall::Syscall,
+    ) -> Result<(), kernel::errorcode::ErrorCode> {
+        use kernel::syscall::Syscall;
+        match *syscall {
+            Syscall::Command {
+                driver_number: nrf52840::nvmc::DRIVER_NUM,
+                subdriver_number: cmd,
+                arg0: ptr,
+                arg1: len,
+            } if (cmd == 2 || cmd == 3) && !process.fits_in_storage_location(ptr, len) => {
+                Err(kernel::ErrorCode::INVAL)
+            }
+            _ => Ok(()),
+        }
+    }
+}
+
+/// This is in a separate, inline(never) function so that its stack frame is
+/// removed when this function returns. Otherwise, the stack space used for
+/// these static_inits is wasted.
+#[inline(never)]
+unsafe fn get_peripherals() -> &'static mut Nrf52840DefaultPeripherals<'static> {
+    // Initialize chip peripheral drivers
+    let nrf52840_peripherals = static_init!(
+        Nrf52840DefaultPeripherals,
+        Nrf52840DefaultPeripherals::new()
+    );
+
+    nrf52840_peripherals
+}
+
+impl KernelResources<nrf52840::chip::NRF52<'static, Nrf52840DefaultPeripherals<'static>>>
+    for Platform
+{
+    type SyscallDriverLookup = Self;
+    type SyscallFilter = ();
+    type ProcessFault = ();
+    type CredentialsCheckingPolicy = ();
+    type Scheduler = RoundRobinSched<'static>;
+    type SchedulerTimer = cortexm4::systick::SysTick;
+    type WatchDog = ();
+    type ContextSwitchCallback = ();
+
+    fn syscall_driver_lookup(&self) -> &Self::SyscallDriverLookup {
+        &self
+    }
+    fn syscall_filter(&self) -> &Self::SyscallFilter {
+        &()
+    }
+    fn process_fault(&self) -> &Self::ProcessFault {
+        &()
+    }
+    fn credentials_checking_policy(&self) -> &'static Self::CredentialsCheckingPolicy {
+        &()
+    }
+    fn scheduler(&self) -> &Self::Scheduler {
+        self.scheduler
+    }
+    fn scheduler_timer(&self) -> &Self::SchedulerTimer {
+        &self.systick
+    }
+    fn watchdog(&self) -> &Self::WatchDog {
+        &()
+    }
+    fn context_switch_callback(&self) -> &Self::ContextSwitchCallback {
+        &()
+    }
+}
+
+/// Main function called after RAM initialized.
+#[no_mangle]
+pub unsafe fn main() {
+    // Loads relocations and clears BSS
+    nrf52840::init();
+    // Initialize chip peripheral drivers
+    let nrf52840_peripherals = get_peripherals();
+
+    // set up circular peripheral dependencies
+    nrf52840_peripherals.init();
+    let base_peripherals = &nrf52840_peripherals.nrf52;
+
+    let uart_channel = if USB_DEBUGGING {
+        // Initialize early so any panic beyond this point can use the RTT memory object.
+        let mut rtt_memory_refs = components::segger_rtt::SeggerRttMemoryComponent::new()
+            .finalize(components::segger_rtt_memory_component_static!());
+
+        // XXX: This is inherently unsafe as it aliases the mutable reference to rtt_memory. This
+        // aliases reference is only used inside a panic handler, which should be OK, but maybe we
+        // should use a const reference to rtt_memory and leverage interior mutability instead.
+        self::io::set_rtt_memory(&mut *rtt_memory_refs.get_rtt_memory_ptr());
+
+        UartChannel::Rtt(rtt_memory_refs)
+    } else {
+        UartChannel::Pins(UartPins::new(UART_RTS, UART_TXD, UART_CTS, UART_RXD))
+    };
+
+    let board_kernel = static_init!(
+        kernel::Kernel,
+        kernel::Kernel::new_with_storage(&PROCESSES, &STORAGE_LOCATIONS)
+    );
+
+    let gpio = components::gpio::GpioComponent::new(
+        board_kernel,
+        capsules::gpio::DRIVER_NUM,
+        components::gpio_component_helper!(
+            nrf52840::gpio::GPIOPin,
+            0 => &nrf52840_peripherals.gpio_port[Pin::P1_01],
+            1 => &nrf52840_peripherals.gpio_port[Pin::P1_02],
+            2 => &nrf52840_peripherals.gpio_port[Pin::P1_03],
+            3 => &nrf52840_peripherals.gpio_port[Pin::P1_04],
+            4 => &nrf52840_peripherals.gpio_port[Pin::P1_05],
+            5 => &nrf52840_peripherals.gpio_port[Pin::P1_06],
+            6 => &nrf52840_peripherals.gpio_port[Pin::P1_07],
+            7 => &nrf52840_peripherals.gpio_port[Pin::P1_08],
+            8 => &nrf52840_peripherals.gpio_port[Pin::P1_10],
+            9 => &nrf52840_peripherals.gpio_port[Pin::P1_11],
+            10 => &nrf52840_peripherals.gpio_port[Pin::P1_12],
+            11 => &nrf52840_peripherals.gpio_port[Pin::P1_13],
+            12 => &nrf52840_peripherals.gpio_port[Pin::P1_14],
+            13 => &nrf52840_peripherals.gpio_port[Pin::P1_15],
+            14 => &nrf52840_peripherals.gpio_port[Pin::P0_26],
+            15 => &nrf52840_peripherals.gpio_port[Pin::P0_27]
+        ),
+    )
+    .finalize(components::gpio_component_static!(nrf52840::gpio::GPIOPin));
+
+    let button = components::button::ButtonComponent::new(
+        board_kernel,
+        capsules::button::DRIVER_NUM,
+        components::button_component_helper!(
+            nrf52840::gpio::GPIOPin,
+            (
+                &nrf52840_peripherals.gpio_port[BUTTON1_PIN],
+                kernel::hil::gpio::ActivationMode::ActiveLow,
+                kernel::hil::gpio::FloatingState::PullUp
+            ), //13
+            (
+                &nrf52840_peripherals.gpio_port[BUTTON2_PIN],
+                kernel::hil::gpio::ActivationMode::ActiveLow,
+                kernel::hil::gpio::FloatingState::PullUp
+            ), //14
+            (
+                &nrf52840_peripherals.gpio_port[BUTTON3_PIN],
+                kernel::hil::gpio::ActivationMode::ActiveLow,
+                kernel::hil::gpio::FloatingState::PullUp
+            ), //15
+            (
+                &nrf52840_peripherals.gpio_port[BUTTON4_PIN],
+                kernel::hil::gpio::ActivationMode::ActiveLow,
+                kernel::hil::gpio::FloatingState::PullUp
+            ) //16
+        ),
+    )
+    .finalize(components::button_component_static!(
+        nrf52840::gpio::GPIOPin
+    ));
+
+    let led = components::led::LedsComponent::new().finalize(components::led_component_static!(
+        LedLow<'static, nrf52840::gpio::GPIOPin>,
+        LedLow::new(&nrf52840_peripherals.gpio_port[LED1_PIN]),
+        LedLow::new(&nrf52840_peripherals.gpio_port[LED2_PIN]),
+        LedLow::new(&nrf52840_peripherals.gpio_port[LED3_PIN]),
+        LedLow::new(&nrf52840_peripherals.gpio_port[LED4_PIN]),
+    ));
+
+    let chip = static_init!(
+        nrf52840::chip::NRF52<Nrf52840DefaultPeripherals>,
+        nrf52840::chip::NRF52::new(nrf52840_peripherals)
+    );
+    CHIP = Some(chip);
+
+    nrf52_components::startup::NrfStartupComponent::new(
+        false,
+        BUTTON_RST_PIN,
+        nrf52840::uicr::Regulator0Output::DEFAULT,
+        &base_peripherals.nvmc,
+    )
+    .finalize(());
+
+    // Create capabilities that the board needs to call certain protected kernel
+    // functions.
+    let process_management_capability =
+        create_capability!(capabilities::ProcessManagementCapability);
+    let main_loop_capability = create_capability!(capabilities::MainLoopCapability);
+    let memory_allocation_capability = create_capability!(capabilities::MemoryAllocationCapability);
+    let gpio_port = &nrf52840_peripherals.gpio_port;
+    // Configure kernel debug gpios as early as possible
+    kernel::debug::assign_gpios(
+        Some(&gpio_port[LED1_PIN]),
+        Some(&gpio_port[LED2_PIN]),
+        Some(&gpio_port[LED3_PIN]),
+    );
+
+    let rtc = &base_peripherals.rtc;
+    let _ = rtc.start();
+    let mux_alarm = components::alarm::AlarmMuxComponent::new(rtc)
+        .finalize(components::alarm_mux_component_static!(nrf52840::rtc::Rtc));
+    let alarm = components::alarm::AlarmDriverComponent::new(
+        board_kernel,
+        capsules::alarm::DRIVER_NUM,
+        mux_alarm,
+    )
+    .finalize(components::alarm_component_static!(nrf52840::rtc::Rtc));
+
+    let channel = nrf52_components::UartChannelComponent::new(
+        uart_channel,
+        mux_alarm,
+        &base_peripherals.uarte0,
+    )
+    .finalize(nrf52_components::uart_channel_component_static!(
+        nrf52840::rtc::Rtc
+    ));
+
+    let dynamic_deferred_call_clients =
+        static_init!([DynamicDeferredCallClientState; 3], Default::default());
+    let dynamic_deferred_caller = static_init!(
+        DynamicDeferredCall,
+        DynamicDeferredCall::new(dynamic_deferred_call_clients)
+    );
+    DynamicDeferredCall::set_global_instance(dynamic_deferred_caller);
+    let process_printer = components::process_printer::ProcessPrinterTextComponent::new()
+        .finalize(components::process_printer_text_component_static!());
+    PROCESS_PRINTER = Some(process_printer);
+
+    // Create a shared UART channel for the console and for kernel debug.
+    let uart_mux =
+        components::console::UartMuxComponent::new(channel, 115200, dynamic_deferred_caller)
+            .finalize(components::uart_mux_component_static!());
+
+    let pconsole = components::process_console::ProcessConsoleComponent::new(
+        board_kernel,
+        uart_mux,
+        mux_alarm,
+        process_printer,
+    )
+    .finalize(components::process_console_component_static!(
+        nrf52840::rtc::Rtc<'static>
+    ));
+
+    // Setup the console.
+    let console = components::console::ConsoleComponent::new(
+        board_kernel,
+        capsules::console::DRIVER_NUM,
+        uart_mux,
+    )
+    .finalize(components::console_component_static!());
+    // Create the debugger object that handles calls to `debug!()`.
+    components::debug_writer::DebugWriterComponent::new(uart_mux)
+        .finalize(components::debug_writer_component_static!());
+
+    let rng = components::rng::RngComponent::new(
+        board_kernel,
+        capsules::rng::DRIVER_NUM,
+        &base_peripherals.trng,
+    )
+    .finalize(components::rng_component_static!());
+
+    base_peripherals.spim0.configure(
+        nrf52840::pinmux::Pinmux::new(SPI_MOSI as u32),
+        nrf52840::pinmux::Pinmux::new(SPI_MISO as u32),
+        nrf52840::pinmux::Pinmux::new(SPI_CLK as u32),
+    );
+
+    // Initialize AC using AIN5 (P0.29) as VIN+ and VIN- as AIN0 (P0.02)
+    // These are hardcoded pin assignments specified in the driver
+    let analog_comparator = components::analog_comparator::AnalogComparatorComponent::new(
+        &base_peripherals.acomp,
+        components::analog_comparator_component_helper!(
+            nrf52840::acomp::Channel,
+            &nrf52840::acomp::CHANNEL_AC0
+        ),
+        board_kernel,
+        capsules::analog_comparator::DRIVER_NUM,
+    )
+    .finalize(components::analog_comparator_component_static!(
+        nrf52840::acomp::Comparator
+    ));
+
+    let nvmc = static_init!(
+        nrf52840::nvmc::SyscallDriver,
+        nrf52840::nvmc::SyscallDriver::new(
+            &base_peripherals.nvmc,
+            board_kernel.create_grant(nrf52840::nvmc::DRIVER_NUM, &memory_allocation_capability),
+            dynamic_deferred_caller,
+        )
+    );
+    nvmc.set_deferred_handle(
+        dynamic_deferred_caller
+            .register(nvmc)
+            .expect("no deferred call slot available for nvmc"),
+    );
+
+    // Configure USB controller
+    let usb = components::usb_ctap::UsbCtapComponent::new(
+        board_kernel,
+        capsules::usb::usb_ctap::DRIVER_NUM,
+        &nrf52840_peripherals.usbd,
+        capsules::usb::usbc_client::MAX_CTRL_PACKET_SIZE_NRF52840,
+        VENDOR_ID,
+        PRODUCT_ID,
+        STRINGS,
+    )
+    .finalize(components::usb_ctap_component_buf!(nrf52840::usbd::Usbd));
+
+    // disable for now
+    // let crp = components::firmware_protection::FirmwareProtectionComponent::new(
+    //     board_kernel,
+    //     nrf52840::uicr::Uicr::new(),
+    // )
+    // .finalize(components::firmware_protection_component_helper!(
+    //     nrf52840::uicr::Uicr
+
+    let scheduler = components::sched::round_robin::RoundRobinComponent::new(&PROCESSES)
+        .finalize(components::round_robin_component_static!(NUM_PROCS)); // ));
+
+    nrf52_components::NrfClockComponent::new(&base_peripherals.clock).finalize(());
+
+    let platform = Platform {
+        button,
+        pconsole,
+        console,
+        led,
+        gpio,
+        rng,
+        alarm,
+        analog_comparator,
+        nvmc,
+        usb,
+        // disable for now
+        //crp,
+        ipc: kernel::ipc::IPC::new(
+            board_kernel,
+            kernel::ipc::DRIVER_NUM,
+            &memory_allocation_capability,
+        ),
+        scheduler,
+        systick: cortexm4::systick::SysTick::new_with_calibration(64000000),
+    };
+
+    let _ = platform.pconsole.start();
+    debug!("Initialization complete. Entering main loop\r");
+    debug!("{}", &nrf52840::ficr::FICR_INSTANCE);
+
+    // These symbols are defined in the linker script.
+    extern "C" {
+        /// Beginning of the ROM region containing app images.
+        static _sapps: u8;
+        /// End of the ROM region containing app images.
+        static _eapps: u8;
+        /// Beginning of the RAM region for app memory.
+        static mut _sappmem: u8;
+        /// End of the RAM region for app memory.
+        static _eappmem: u8;
+    }
+
+    kernel::process::load_processes(
+        board_kernel,
+        chip,
+        core::slice::from_raw_parts(
+            &_sapps as *const u8,
+            &_eapps as *const u8 as usize - &_sapps as *const u8 as usize,
+        ),
+        core::slice::from_raw_parts_mut(
+            &mut _sappmem as *mut u8,
+            &_eappmem as *const u8 as usize - &_sappmem as *const u8 as usize,
+        ),
+        &mut PROCESSES,
+        &FAULT_RESPONSE,
+        &process_management_capability,
+    )
+    .unwrap_or_else(|err| {
+        debug!("Error loading processes!");
+        debug!("{:?}", err);
+    });
+
+    board_kernel.kernel_loop(&platform, chip, Some(&platform.ipc), &main_loop_capability);
+}
-- 
2.34.1


From 429c4275b1898d8bc6a23d212446e6197054042e Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Thu, 8 Dec 2022 18:50:11 +0100
Subject: [PATCH 19/27] Enable debugging of syscalls/processes to nrf52840dk

---
 boards/nordic/nrf52840_chip_layout.ld      | 1 +
 boards/nordic/nrf52840dk_opensk/Cargo.toml | 5 ++++-
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/boards/nordic/nrf52840_chip_layout.ld b/boards/nordic/nrf52840_chip_layout.ld
index 37c0c74d7..e8906f050 100644
--- a/boards/nordic/nrf52840_chip_layout.ld
+++ b/boards/nordic/nrf52840_chip_layout.ld
@@ -7,3 +7,4 @@ MEMORY
 }
 
 PAGE_SIZE = 4K;
+MPU_MIN_ALIGN = 8K;
diff --git a/boards/nordic/nrf52840dk_opensk/Cargo.toml b/boards/nordic/nrf52840dk_opensk/Cargo.toml
index 03d6f1d15..1f43158a9 100644
--- a/boards/nordic/nrf52840dk_opensk/Cargo.toml
+++ b/boards/nordic/nrf52840dk_opensk/Cargo.toml
@@ -9,7 +9,10 @@ edition = "2018"
 components = { path = "../../components" }
 cortexm4 = { path = "../../../arch/cortex-m4" }
 capsules = { path = "../../../capsules" }
-kernel = { path = "../../../kernel" }
+kernel = { path = "../../../kernel", features = [
+	"debug_load_processes",
+	"trace_syscalls",
+] }
 nrf52840 = { path = "../../../chips/nrf52840" }
 nrf52_components = { path = "../nrf52_components" }
 
-- 
2.34.1


From 9d728bb39a9ced53bb38e784e8700a2133999231 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Sat, 10 Dec 2022 15:15:21 +0100
Subject: [PATCH 20/27] Disable trace syscalls feature for nordic board

---
 boards/nordic/nrf52840dk_opensk/Cargo.toml | 1 -
 1 file changed, 1 deletion(-)

diff --git a/boards/nordic/nrf52840dk_opensk/Cargo.toml b/boards/nordic/nrf52840dk_opensk/Cargo.toml
index 1f43158a9..8f1eceeb8 100644
--- a/boards/nordic/nrf52840dk_opensk/Cargo.toml
+++ b/boards/nordic/nrf52840dk_opensk/Cargo.toml
@@ -11,7 +11,6 @@ cortexm4 = { path = "../../../arch/cortex-m4" }
 capsules = { path = "../../../capsules" }
 kernel = { path = "../../../kernel", features = [
 	"debug_load_processes",
-	"trace_syscalls",
 ] }
 nrf52840 = { path = "../../../chips/nrf52840" }
 nrf52_components = { path = "../nrf52_components" }
-- 
2.34.1


From a15a3b38184ed50f9fe5e80ce07283497aa9bff2 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Sun, 11 Dec 2022 22:23:36 +0100
Subject: [PATCH 21/27] Change MAX_WORD_WRITES and MAX_WORD_ERASES to u32

---
 chips/nrf52/src/nvmc.rs | 16 +++++++---------
 1 file changed, 7 insertions(+), 9 deletions(-)

diff --git a/chips/nrf52/src/nvmc.rs b/chips/nrf52/src/nvmc.rs
index a1194dc53..6ab34b11b 100644
--- a/chips/nrf52/src/nvmc.rs
+++ b/chips/nrf52/src/nvmc.rs
@@ -152,8 +152,8 @@ static DEFERRED_CALL: DeferredCall<DeferredCallTask> =
 type WORD = u32;
 const WORD_SIZE: usize = core::mem::size_of::<WORD>();
 const PAGE_SIZE: usize = 4096;
-const MAX_WORD_WRITES: usize = 2;
-const MAX_PAGE_ERASES: usize = 10000;
+const MAX_WORD_WRITES: u32 = 2;
+const MAX_PAGE_ERASES: u32 = 10_000;
 const WORD_MASK: usize = WORD_SIZE - 1;
 const PAGE_MASK: usize = PAGE_SIZE - 1;
 
@@ -170,13 +170,11 @@ const PAGE_MASK: usize = PAGE_SIZE - 1;
 ///
 /// let pagebuffer = unsafe { static_init!(NrfPage, NrfPage::default()) };
 /// ```
-pub struct NrfPage(pub [u8; PAGE_SIZE as usize]);
+pub struct NrfPage(pub [u8; PAGE_SIZE]);
 
 impl Default for NrfPage {
     fn default() -> Self {
-        Self {
-            0: [0; PAGE_SIZE as usize],
-        }
+        Self { 0: [0; PAGE_SIZE] }
     }
 }
 impl NrfPage {
@@ -454,7 +452,7 @@ pub struct SyscallDriver {
     deferred_handle: OptionalCell<DeferredCallHandle>,
 }
 
-pub const DRIVER_NUM: usize = 0x50003;
+pub const DRIVER_NUM: usize = 0x50_003;
 
 #[derive(Default)]
 pub struct App {}
@@ -568,8 +566,8 @@ impl kernel::syscall::SyscallDriver for SyscallDriver {
 
             (1, 0, _) => CommandReturn::success_u32(WORD_SIZE.try_into().unwrap()),
             (1, 1, _) => CommandReturn::success_u32(PAGE_SIZE.try_into().unwrap()),
-            (1, 2, _) => CommandReturn::success_u32(MAX_WORD_WRITES.try_into().unwrap()),
-            (1, 3, _) => CommandReturn::success_u32(MAX_PAGE_ERASES.try_into().unwrap()),
+            (1, 2, _) => CommandReturn::success_u32(MAX_WORD_WRITES),
+            (1, 3, _) => CommandReturn::success_u32(MAX_PAGE_ERASES),
             (1, _, _) => CommandReturn::failure(ErrorCode::INVAL),
 
             (2, ptr, len) => self
-- 
2.34.1


From fe8e100c61bc26a0ef7a3ac62264c8bfcfc25124 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Mon, 12 Dec 2022 22:31:12 +0100
Subject: [PATCH 22/27] Add missing kernel memop cmds

---
 kernel/src/memop.rs | 26 ++++++++++++++++++++++++--
 1 file changed, 24 insertions(+), 2 deletions(-)

diff --git a/kernel/src/memop.rs b/kernel/src/memop.rs
index 4d47f77d2..45ab3856b 100644
--- a/kernel/src/memop.rs
+++ b/kernel/src/memop.rs
@@ -107,12 +107,34 @@ pub(crate) fn memop(process: &dyn Process, op_type: usize, r1: usize) -> Syscall
             SyscallReturn::Success
         }
 
+        // 12 - 15 are required for the custom persistent store driver
+        // currently only implemented in the nvmc module of nrf52 series
+        // driver number: 0x50_003
+
+        // Op Type 12: Number of storage locations
+        12 => SyscallReturn::SuccessU32(process.number_storage_locations() as u32),
+
+        // Op Type 13: The start address of the storage location indexed by r1
+        13 => {
+            match process.get_storage_location(r1) {
+                None => SyscallReturn::Failure(ErrorCode::FAIL),
+                Some(x) => SyscallReturn::SuccessU32(x.address as u32),
+            }
+        }
+
+        // Op Type 14: The size of the storage location indexed by r1.
+        14 => {
+            match process.get_storage_location(r1) {
+                None => SyscallReturn::Failure(ErrorCode::FAIL),
+                Some(x) => SyscallReturn::SuccessU32(x.size as u32),
+            }
+        }
+
         // Op Type 15: The type of the storage location indexed by r1.
         15 => {
             match process.get_storage_location(r1) {
                 None => SyscallReturn::Failure(ErrorCode::FAIL),
-                //Some(x) => ReturnCode::SuccessWithValue { value: x.storage_type as usize }
-                Some(x) => SyscallReturn::SuccessU32(x.storage_type.try_into().unwrap())
+                Some(x) => SyscallReturn::SuccessU32(x.storage_type as u32)
             }
         }
 
-- 
2.34.1


From e99e5e4552ec5711151238de9eac038345b2bfae Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Thu, 15 Dec 2022 22:38:49 +0100
Subject: [PATCH 23/27] Fix nrf52 nvmc driver

---
 .../nordic/nrf52840_dongle_opensk/src/main.rs |  4 ++
 boards/nordic/nrf52840dk_opensk/src/main.rs   |  4 ++
 chips/nrf52/src/nvmc.rs                       | 64 ++++++++++++-------
 3 files changed, 48 insertions(+), 24 deletions(-)

diff --git a/boards/nordic/nrf52840_dongle_opensk/src/main.rs b/boards/nordic/nrf52840_dongle_opensk/src/main.rs
index 7f5df6db3..62b5f48b7 100644
--- a/boards/nordic/nrf52840_dongle_opensk/src/main.rs
+++ b/boards/nordic/nrf52840_dongle_opensk/src/main.rs
@@ -87,6 +87,9 @@ static mut CHIP: Option<&'static nrf52840::chip::NRF52<Nrf52840DefaultPeripheral
 // Static reference to process printer for panic dumps
 static mut PROCESS_PRINTER: Option<&'static kernel::process::ProcessPrinterText> = None;
 
+/// Flash buffer for the custom nvmc driver
+static mut APP_FLASH_BUFFER: [u8; 512] = [0; 512];
+
 /// Dummy buffer that causes the linker to reserve enough space for the stack.
 #[no_mangle]
 #[link_section = ".stack_buffer"]
@@ -420,6 +423,7 @@ pub unsafe fn main() {
             &base_peripherals.nvmc,
             board_kernel.create_grant(nrf52840::nvmc::DRIVER_NUM, &memory_allocation_capability),
             dynamic_deferred_caller,
+            &mut APP_FLASH_BUFFER,
         )
     );
     nvmc.set_deferred_handle(
diff --git a/boards/nordic/nrf52840dk_opensk/src/main.rs b/boards/nordic/nrf52840dk_opensk/src/main.rs
index 88baf5024..96d31e02f 100644
--- a/boards/nordic/nrf52840dk_opensk/src/main.rs
+++ b/boards/nordic/nrf52840dk_opensk/src/main.rs
@@ -136,6 +136,9 @@ include!(concat!(env!("OUT_DIR"), "/locations.rs"));
 static mut CHIP: Option<&'static nrf52840::chip::NRF52<Nrf52840DefaultPeripherals>> = None;
 static mut PROCESS_PRINTER: Option<&'static kernel::process::ProcessPrinterText> = None;
 
+/// Flash buffer for the custom nvmc driver
+static mut APP_FLASH_BUFFER: [u8; 512] = [0; 512];
+
 /// Dummy buffer that causes the linker to reserve enough space for the stack.
 #[no_mangle]
 #[link_section = ".stack_buffer"]
@@ -488,6 +491,7 @@ pub unsafe fn main() {
             &base_peripherals.nvmc,
             board_kernel.create_grant(nrf52840::nvmc::DRIVER_NUM, &memory_allocation_capability),
             dynamic_deferred_caller,
+            &mut APP_FLASH_BUFFER,
         )
     );
     nvmc.set_deferred_handle(
diff --git a/chips/nrf52/src/nvmc.rs b/chips/nrf52/src/nvmc.rs
index 6ab34b11b..b7c3be3f6 100644
--- a/chips/nrf52/src/nvmc.rs
+++ b/chips/nrf52/src/nvmc.rs
@@ -450,6 +450,7 @@ pub struct SyscallDriver {
     waiting: OptionalCell<ProcessId>,
     deferred_caller: &'static DynamicDeferredCall,
     deferred_handle: OptionalCell<DeferredCallHandle>,
+    buffer: TakeCell<'static, [u8]>,
 }
 
 pub const DRIVER_NUM: usize = 0x50_003;
@@ -467,6 +468,7 @@ impl SyscallDriver {
         nvmc: &'static Nvmc,
         apps: NvmcDriverGrant,
         deferred_caller: &'static DynamicDeferredCall,
+        buffer: &'static mut [u8],
     ) -> SyscallDriver {
         nvmc.configure_readonly();
         SyscallDriver {
@@ -475,6 +477,7 @@ impl SyscallDriver {
             waiting: OptionalCell::empty(),
             deferred_caller,
             deferred_handle: OptionalCell::empty(),
+            buffer: TakeCell::new(buffer),
         }
     }
 
@@ -570,33 +573,46 @@ impl kernel::syscall::SyscallDriver for SyscallDriver {
             (1, 3, _) => CommandReturn::success_u32(MAX_PAGE_ERASES),
             (1, _, _) => CommandReturn::failure(ErrorCode::INVAL),
 
-            (2, ptr, len) => self
+            (2, ptr, _len) => self
                 .apps
                 .enter(process_id, |_, kernel| {
-                    let process_buffer = match kernel.get_readonly_processbuffer(1) {
-                        Ok(buf) => buf,
-                        Err(e) => return CommandReturn::failure(ErrorCode::from(e)),
-                    };
-
-                    let slice = match process_buffer.enter(|slice| {
-                        let mut buf: [u8; WORD_SIZE] = [0; WORD_SIZE];
-                        slice.copy_to_slice(&mut buf);
-                        buf
-                    }) {
-                        Ok(buf) => buf,
-                        Err(e) => return CommandReturn::failure(ErrorCode::from(e)),
-                    };
-
-                    if len != slice.len() {
-                        return CommandReturn::failure(ErrorCode::INVAL);
-                    }
-                    if self.waiting.is_some() {
-                        return CommandReturn::failure(ErrorCode::BUSY);
-                    }
-                    self.waiting.set(process_id);
-                    self.write_slice(ptr, slice.as_ref())
+                    kernel
+                        .get_readonly_processbuffer(0)
+                        .and_then(|processbuffer| {
+                            processbuffer.enter(|app_buf| {
+                                // Copy contents to the internal buffer first
+                                self.buffer.take().map_or(
+                                    CommandReturn::failure(ErrorCode::RESERVE),
+                                    |buffer| {
+                                        // as the drivers buffer can be bigger than the app buffer,
+                                        // we choose the minimum to not copy anymore than we need
+                                        let len = core::cmp::min(buffer.len(), app_buf.len());
+
+                                        // safety check when the app buffer is too large
+                                        if app_buf.len() > buffer.len() {
+                                            return CommandReturn::failure(ErrorCode::INVAL);
+                                        }
+
+                                        let d = &app_buf[0..len];
+                                        for (i, v) in buffer.as_mut()[0..len].iter_mut().enumerate()
+                                        {
+                                            *v = d[i].get();
+                                        }
+
+                                        if self.waiting.is_some() {
+                                            return CommandReturn::failure(ErrorCode::BUSY);
+                                        }
+                                        self.waiting.set(process_id);
+                                        let result = self.write_slice(ptr, &buffer[0..len]);
+                                        self.buffer.replace(buffer);
+                                        result
+                                    },
+                                )
+                            })
+                        })
+                        .unwrap_or(CommandReturn::failure(ErrorCode::RESERVE))
                 })
-                .unwrap_or_else(|err| err.into()),
+                .unwrap_or_else(|e| CommandReturn::failure(e.into())),
 
             (3, ptr, len) => {
                 if len != PAGE_SIZE {
-- 
2.34.1


From e3fbf5027b48e32879bd704603865690254ac297 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Mon, 19 Dec 2022 18:18:42 +0100
Subject: [PATCH 24/27] Fix `upcalls::RECEIVED` upcall in usb ctap

---
 capsules/src/usb/usb_ctap.rs | 29 ++++++++++++-----------------
 1 file changed, 12 insertions(+), 17 deletions(-)

diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index f3b22a849..e3735780b 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -76,26 +76,21 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbSyscallDriver<'a, 'b, C> {
         packet: &[u8; 64],
         endpoint: usize,
         app: &mut App,
-        kernel_data: &GrantKernelData,
+        kernel: &GrantKernelData,
     ) {
         if app.connected && app.waiting && app.side.map_or(false, |side| side.can_receive()) {
-            kernel_data
+            let _ = kernel
                 .get_readwrite_processbuffer(rw_allow::RECEIVE)
-                .and_then(|process_buffer| {
-                    process_buffer
-                        .mut_enter(|buf| buf.copy_from_slice(packet))
-                        .unwrap();
-                    app.waiting = false;
-                    // Signal to the app that a packet is ready.
-                    kernel_data
-                        .schedule_upcall(upcalls::RECEIVED, (endpoint, 0, 0))
-                        .unwrap();
-                    // reset the client state
-                    app.check_side();
-
-                    Ok(())
-                })
-                .unwrap();
+                .and_then(|recv| recv.mut_enter(|dest| dest.copy_from_slice(packet)));
+            app.waiting = false;
+            // Signal to the app that a packet is ready.
+            // TODO: passing the upcallid again in the registers is not needed anymore with Tock 2.0,
+            // but is currently still there for backwards compatibility
+            kernel
+                .schedule_upcall(upcalls::RECEIVED, (upcalls::RECEIVED, endpoint, 0))
+                .ok();
+            // reset the client state
+            app.check_side();
         }
     }
 }
-- 
2.34.1


From a48eb235211e49986edfa83d19af350a1b0daf32 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Mon, 19 Dec 2022 19:06:50 +0100
Subject: [PATCH 25/27] Fix `upcalls::TRANSMITTED` upcall in usb ctap

---
 capsules/src/usb/usb_ctap.rs | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index e3735780b..c33101f32 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -34,7 +34,8 @@ mod rw_allow {
 
 /// Ids for scheduling the upcalls
 ///
-/// They **must** match the the subscribe numbers which were used by the process.
+/// They **must** match the the subscribe numbers which were used by the process to
+/// subscribe to the upcall.
 mod upcalls {
     pub const TRANSMITTED: usize = 0;
     pub const RECEIVED: usize = 1;
@@ -83,14 +84,14 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbSyscallDriver<'a, 'b, C> {
                 .get_readwrite_processbuffer(rw_allow::RECEIVE)
                 .and_then(|recv| recv.mut_enter(|dest| dest.copy_from_slice(packet)));
             app.waiting = false;
+            // reset the client state
+            app.check_side();
             // Signal to the app that a packet is ready.
             // TODO: passing the upcallid again in the registers is not needed anymore with Tock 2.0,
             // but is currently still there for backwards compatibility
             kernel
                 .schedule_upcall(upcalls::RECEIVED, (upcalls::RECEIVED, endpoint, 0))
                 .ok();
-            // reset the client state
-            app.check_side();
         }
     }
 }
@@ -130,13 +131,12 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDri
                     && app.side.map_or(false, |side| side.can_transmit())
                 {
                     app.waiting = false;
+                    // reset the client state
+                    app.check_side();
                     // Signal to the app that the packet was sent.
                     kernel_data
-                        .schedule_upcall(upcalls::TRANSMITTED, (0, 0, 0))
+                        .schedule_upcall(upcalls::TRANSMITTED, (upcalls::TRANSMITTED, 0, 0))
                         .unwrap();
-
-                    // reset the client state
-                    app.check_side();
                 }
             });
         }
-- 
2.34.1


From aec49324e67c980479398bb5b9f97dfa6b9764e3 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Tue, 27 Dec 2022 16:42:28 +0100
Subject: [PATCH 26/27] Update setting up static space for usb ctap driver

---
 boards/components/src/usb_ctap.rs              | 18 +++++++++++-------
 .../nordic/nrf52840_dongle_opensk/src/main.rs  |  5 +++--
 boards/nordic/nrf52840dk_opensk/src/main.rs    |  6 +++---
 capsules/src/usb/usbc_ctap_hid.rs              |  8 +++++---
 4 files changed, 22 insertions(+), 15 deletions(-)

diff --git a/boards/components/src/usb_ctap.rs b/boards/components/src/usb_ctap.rs
index bfee8c832..5fadcd801 100644
--- a/boards/components/src/usb_ctap.rs
+++ b/boards/components/src/usb_ctap.rs
@@ -10,15 +10,19 @@ use kernel::hil;
 
 // Setup static space for the objects.
 #[macro_export]
-macro_rules! usb_ctap_component_buf {
-    ($C:ty) => {{
+macro_rules! usb_ctap_component_static {
+    ($C:ty $(,)?) => {{
         use capsules::usb::usb_ctap::CtapUsbSyscallDriver;
         use capsules::usb::usbc_ctap_hid::ClientCtapHID;
-        use core::mem::MaybeUninit;
-        static mut BUF1: MaybeUninit<ClientCtapHID<'static, 'static, $C>> = MaybeUninit::uninit();
-        static mut BUF2: MaybeUninit<CtapUsbSyscallDriver<'static, 'static, $C>> =
-            MaybeUninit::uninit();
-        (&mut BUF1, &mut BUF2)
+        // use core::mem::MaybeUninit;
+        // static mut BUF1: MaybeUninit<ClientCtapHID<'static, 'static, $C>> = MaybeUninit::uninit();
+        // static mut BUF2: MaybeUninit<CtapUsbSyscallDriver<'static, 'static, $C>> =
+        //     MaybeUninit::uninit();
+        let hid = kernel::static_buf!(ClientCtapHID<'static, 'static, $C>);
+        let driver = kernel::static_buf!(CtapUsbSyscallDriver<'static, 'static, $C>);
+
+
+        (hid, driver)
     };};
 }
 
diff --git a/boards/nordic/nrf52840_dongle_opensk/src/main.rs b/boards/nordic/nrf52840_dongle_opensk/src/main.rs
index 62b5f48b7..d5774d3d6 100644
--- a/boards/nordic/nrf52840_dongle_opensk/src/main.rs
+++ b/boards/nordic/nrf52840_dongle_opensk/src/main.rs
@@ -431,6 +431,7 @@ pub unsafe fn main() {
             .register(nvmc)
             .expect("no deferred call slot available for nvmc"),
     );
+
     // Configure USB controller
     let usb = components::usb_ctap::UsbCtapComponent::new(
         board_kernel,
@@ -441,7 +442,7 @@ pub unsafe fn main() {
         PRODUCT_ID,
         STRINGS,
     )
-    .finalize(components::usb_ctap_component_buf!(nrf52840::usbd::Usbd));
+    .finalize(components::usb_ctap_component_static!(nrf52840::usbd::Usbd));
 
     // not backported yet
     // let crp = components::firmware_protection::FirmwareProtectionComponent::new(
@@ -468,7 +469,6 @@ pub unsafe fn main() {
         analog_comparator,
         nvmc,
         usb,
-        //crp
         ipc: kernel::ipc::IPC::new(
             board_kernel,
             kernel::ipc::DRIVER_NUM,
@@ -476,6 +476,7 @@ pub unsafe fn main() {
         ),
         scheduler,
         systick: cortexm4::systick::SysTick::new_with_calibration(64000000),
+        //crp
     };
 
     let _ = platform.pconsole.start();
diff --git a/boards/nordic/nrf52840dk_opensk/src/main.rs b/boards/nordic/nrf52840dk_opensk/src/main.rs
index 96d31e02f..e75223ff0 100644
--- a/boards/nordic/nrf52840dk_opensk/src/main.rs
+++ b/boards/nordic/nrf52840dk_opensk/src/main.rs
@@ -510,7 +510,7 @@ pub unsafe fn main() {
         PRODUCT_ID,
         STRINGS,
     )
-    .finalize(components::usb_ctap_component_buf!(nrf52840::usbd::Usbd));
+    .finalize(components::usb_ctap_component_static!(nrf52840::usbd::Usbd));
 
     // disable for now
     // let crp = components::firmware_protection::FirmwareProtectionComponent::new(
@@ -536,8 +536,6 @@ pub unsafe fn main() {
         analog_comparator,
         nvmc,
         usb,
-        // disable for now
-        //crp,
         ipc: kernel::ipc::IPC::new(
             board_kernel,
             kernel::ipc::DRIVER_NUM,
@@ -545,6 +543,8 @@ pub unsafe fn main() {
         ),
         scheduler,
         systick: cortexm4::systick::SysTick::new_with_calibration(64000000),
+        // disable for now
+        //crp,
     };
 
     let _ = platform.pconsole.start();
diff --git a/capsules/src/usb/usbc_ctap_hid.rs b/capsules/src/usb/usbc_ctap_hid.rs
index e5ea9ecb2..fee0ba56c 100644
--- a/capsules/src/usb/usbc_ctap_hid.rs
+++ b/capsules/src/usb/usbc_ctap_hid.rs
@@ -164,9 +164,10 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
         let interfaces: &mut [InterfaceDescriptor] = &mut [
             // Interface declared in the FIDO2 specification, section 8.1.8.1
             InterfaceDescriptor {
-                interface_class: 0x03, // HID
-                interface_subclass: 0x00,
-                interface_protocol: 0x00,
+                interface_number: 0,
+                interface_class: 0x03,    // HID
+                interface_subclass: 0x00, // no subcall
+                interface_protocol: 0x00, // no protocol
                 ..InterfaceDescriptor::default()
             },
             // Vendor HID interface.
@@ -234,6 +235,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
                     manufacturer_string: 1,
                     product_string: 2,
                     serial_number_string: 3,
+                    class: 0x03, // HID class for all interfaces
                     max_packet_size_ep0: max_ctrl_packet_size,
                     ..descriptors::DeviceDescriptor::default()
                 },
-- 
2.34.1


From c74bb9d47c0cb25a418c7a311b1cad5f86d4a7b7 Mon Sep 17 00:00:00 2001
From: L0g4n <yannik.klubertanz@posteo.de>
Date: Thu, 5 Jan 2023 18:34:27 +0100
Subject: [PATCH 27/27] Fix double app re-entry

---
 boards/nordic/nrf52840dk_opensk/src/main.rs |  2 +-
 capsules/src/usb/usb_ctap.rs                | 43 +++++++++++++++------
 capsules/src/usb/usbc_ctap_hid.rs           | 16 +++++---
 3 files changed, 43 insertions(+), 18 deletions(-)

diff --git a/boards/nordic/nrf52840dk_opensk/src/main.rs b/boards/nordic/nrf52840dk_opensk/src/main.rs
index e75223ff0..54332462b 100644
--- a/boards/nordic/nrf52840dk_opensk/src/main.rs
+++ b/boards/nordic/nrf52840dk_opensk/src/main.rs
@@ -108,7 +108,7 @@ pub mod io;
 // Whether to use UART debugging or Segger RTT (USB) debugging.
 // - Set to false to use UART.
 // - Set to true to use Segger RTT over USB.
-const USB_DEBUGGING: bool = true;
+const USB_DEBUGGING: bool = false;
 
 const VENDOR_ID: u16 = 0x1915; // Nordic Semiconductor
 const PRODUCT_ID: u16 = 0x521f; // nRF52840 Dongle (PCA10059)
diff --git a/capsules/src/usb/usb_ctap.rs b/capsules/src/usb/usb_ctap.rs
index c33101f32..0fd4407c4 100644
--- a/capsules/src/usb/usb_ctap.rs
+++ b/capsules/src/usb/usb_ctap.rs
@@ -56,7 +56,12 @@ pub trait CtapUsbClient {
     fn can_receive_packet(&self, app: &Option<&mut App>) -> bool;
 
     // Signal to the client that a packet has been received.
-    fn packet_received(&self, packet: &[u8; 64], endpoint: usize, app: Option<&mut App>);
+    fn packet_received(
+        &self,
+        packet: &[u8; 64],
+        endpoint: usize,
+        app_data: (Option<&mut App>, Option<&GrantKernelData>),
+    );
 
     // Signal to the client that a packet has been transmitted.
     fn packet_transmitted(&self);
@@ -114,12 +119,26 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> CtapUsbClient for CtapUsbSyscallDri
         result
     }
 
-    // TODO: interface weird. we need the reentry to get the kernel data
-    fn packet_received(&self, packet: &[u8; 64], endpoint: usize, _app: Option<&mut App>) {
-        for app in self.apps.iter() {
-            app.enter(|a, kernel_data| {
-                self.app_packet_received(packet, endpoint, a, kernel_data);
-            })
+    fn packet_received(
+        &self,
+        packet: &[u8; 64],
+        endpoint: usize,
+        app_data: (Option<&mut App>, Option<&GrantKernelData>),
+    ) {
+        match app_data {
+            (None, _) => {
+                for app in self.apps.iter() {
+                    app.enter(|a, kernel_grant| {
+                        self.app_packet_received(packet, endpoint, a, kernel_grant);
+                    })
+                }
+            }
+            (Some(app), Some(kernel_grant)) => {
+                self.app_packet_received(packet, endpoint, app, kernel_grant)
+            }
+            // this should never happen as having a valid app always results
+            // in also having the grant data
+            _ => panic!("invalid app_data combination!"),
         }
     }
 
@@ -222,7 +241,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                 .unwrap_or_else(|err| err.into()),
             CTAP_CMD_RECEIVE => self
                 .apps
-                .enter(process_id, |app, _| {
+                .enter(process_id, |app, kernel_grant| {
                     if !app.connected {
                         CommandReturn::failure(ErrorCode::RESERVE)
                     } else {
@@ -235,7 +254,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                                 CommandReturn::failure(ErrorCode::ALREADY)
                             } else {
                                 app.waiting = true;
-                                self.usb_client.receive_packet(app);
+                                self.usb_client.receive_packet(app, kernel_grant);
                                 CommandReturn::success()
                             }
                         } else {
@@ -246,7 +265,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                 .unwrap_or_else(|err| err.into()),
             CTAP_CMD_TRANSMIT_OR_RECEIVE => self
                 .apps
-                .enter(process_id, |app, kernel| {
+                .enter(process_id, |app, kernel_grant| {
                     if !app.connected {
                         CommandReturn::failure(ErrorCode::RESERVE)
                     } else {
@@ -260,7 +279,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
                                 CommandReturn::failure(ErrorCode::ALREADY)
                             } else {
                                 // send a packet before receiving one
-                                let r = kernel
+                                let r = kernel_grant
                                     .get_readonly_processbuffer(ro_allow::TRANSMIT_OR_RECEIVE)
                                     .and_then(|process_buffer| {
                                         process_buffer.enter(|buf| {
@@ -278,7 +297,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> SyscallDriver for CtapUsbSyscallDri
 
                                 // Indicates to the driver that we can receive any pending packet.
                                 app.waiting = true;
-                                self.usb_client.receive_packet(app);
+                                self.usb_client.receive_packet(app, kernel_grant);
 
                                 CommandReturn::success()
                             }
diff --git a/capsules/src/usb/usbc_ctap_hid.rs b/capsules/src/usb/usbc_ctap_hid.rs
index fee0ba56c..e074eb7a6 100644
--- a/capsules/src/usb/usbc_ctap_hid.rs
+++ b/capsules/src/usb/usbc_ctap_hid.rs
@@ -16,6 +16,7 @@ use super::usb_ctap::CtapUsbClient;
 use super::usbc_client_ctrl::ClientCtrl;
 use core::cell::Cell;
 use kernel::debug;
+use kernel::grant::GrantKernelData;
 use kernel::hil;
 use kernel::hil::usb::TransferType;
 use kernel::syscall::CommandReturn;
@@ -314,7 +315,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
         }
     }
 
-    pub fn receive_packet(&'a self, app: &mut App) {
+    pub fn receive_packet(&'a self, app: &mut App, kernel_grant: &GrantKernelData) {
         if self.pending_out.get() {
             // The previous packet has not yet been received, reject the new one.
         } else {
@@ -327,7 +328,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
                 // Otherwise, there's nothing to do, the controller will send us a packet_out when a
                 // packet arrives.
                 if s.delayed_out.take() {
-                    if self.send_packet_to_client(s.endpoint, Some(app)) {
+                    if self.send_packet_to_client(s.endpoint, Some(app), Some(kernel_grant)) {
                         // If that succeeds, alert the controller that we can now
                         // receive data on the Interrupt OUT endpoint.
                         self.controller().endpoint_resume_out(s.endpoint);
@@ -340,7 +341,12 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
     // Send an OUT packet available in the controller back to the client.
     // This returns false if the client is not ready to receive a packet, and true if the client
     // successfully accepted the packet.
-    fn send_packet_to_client(&'a self, endpoint: usize, app: Option<&mut App>) -> bool {
+    fn send_packet_to_client(
+        &'a self,
+        endpoint: usize,
+        app: Option<&mut App>,
+        kernel_grant: Option<&GrantKernelData>,
+    ) -> bool {
         if let Some(s) = self.get_endpoint(endpoint) {
             // Copy the packet into a buffer to send to the client.
             let mut buf: [u8; 64] = [0; 64];
@@ -363,7 +369,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> ClientCtapHID<'a, 'b, C> {
                 self.cancel_in_transaction(endpoint);
 
                 self.client
-                    .map(|client| client.packet_received(&buf, endpoint, app));
+                    .map(|client| client.packet_received(&buf, endpoint, (app, kernel_grant)));
                 // Update next packet to send.
                 for (i, ep) in self.endpoints.iter().enumerate() {
                     if ep.endpoint == endpoint {
@@ -514,7 +520,7 @@ impl<'a, 'b, C: hil::usb::UsbController<'a>> hil::usb::Client<'a> for ClientCtap
                     // Cannot process this packet
                     hil::usb::OutResult::Error
                 } else {
-                    if self.send_packet_to_client(endpoint, None) {
+                    if self.send_packet_to_client(endpoint, None, None) {
                         hil::usb::OutResult::Ok
                     } else {
                         hil::usb::OutResult::Delay
-- 
2.34.1

